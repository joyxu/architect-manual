{"./":{"url":"./","title":"架构师手册","keywords":"","body":"架构师手册 架构，是一种递进的能力。 在线阅读 可以通过GitBook或者Github来在线阅读。 也可以下载PDF、ePub或者Mobi版本。 项目源码 项目源码存放于Github上，见https://github.com/tonydeng/architect-manual。 "},"ch1/":{"url":"ch1/","title":"第1章 手册简介","keywords":"","body":"第1章 手册简介 架构设计能力，因为掌握起来而显得珍贵。 期望用这本手册来概括一线架构师经常面对的实践困惑，并给出ADMEMS方法的应对之策。 扩展阅读 软件架构在不断发展，但它依然是一个尚不成熟的学科。 --Len Bass 《软件架构实践（第2版）》 推动软件工程研究不断发展的，常是实际生产或使用软件时遇到的。 -- Mary Shaw, 《The Golden Age of Software Architecture》 "},"ch1/1.1.html":{"url":"ch1/1.1.html","title":"1.1. 一线架构师:6个经典困惑","keywords":"","body":"1.1. 一线架构师:6个经典困惑 一线架构师经常面对的实践困惑，可以用下面的图来概括。其中，涉及了“4个实际问题的困惑”，以及“两个职业发展的困惑”。 "},"ch1/1.2.html":{"url":"ch1/1.2.html","title":"1.2. 4个核心主张","keywords":"","body":"1.2. 4个核心主张 画龙须点睛。 在介绍具体方法之前，先阐述4个核心主张。 方法体系是大趋势 质疑驱动的架构设计 多阶段方法 内置最佳实践的方法 这4个核心主张可帮助读者领会ADMEMS方法之精神。 "},"ch1/1.2.1.html":{"url":"ch1/1.2.1.html","title":"1.2.1. 方法体系是大趋势","keywords":"","body":"1.2.1. 方法体系是大趋势 单一方法已经无法解决复杂的业务需求，一线架构师真正需要的是覆盖“需请进，架构出”全过程的实践指导。 只有综合了不同方法优点的“方法体系”才能堪此重任。 ADMEMS是“Architectural Design Method has been Extended Method System”的缩写。ADMEMS并不是单一方法，而是由多个各具特点的方法组成的方法体系。 ADMEMS 是“Architectural Design Method has been Extended to Method System(将架构设计方法扩展到方法体系)”的缩写。 "},"ch1/1.2.2.html":{"url":"ch1/1.2.2.html","title":"1.2.2. 质疑驱动的架构设计","keywords":"","body":"1.2.2. 质疑驱动的架构设计 毫无疑问，架构设计是需求驱动的，而不是模型驱动的。 但需求驱动的说法，不太传神——当你很清楚需求却依然设计不出架构时就足以 说明“需求驱动的架构设计”的总结还“缺点儿什么”。 架构设计是一门艺术，你不可能把“一桶需求”倒进某台神奇的机器然后等着架构设计自动被“加工生产”完毕，因此“需求驱动的架构设计”给架构师的启发不够。 缺点儿什么呢? 答案是，缺“人的因素”、“架构师的因素”! 接下来将不断阐述架构设计实际上是个“质疑驱动的过程”: 需求，被架构师的大脑(而不是自动)，有节奏地引入到架构设计的一波接一波的思维活动中。 例如，作为架构师，当你的架构设计进行到一半时，你可以明显感觉到:这个架构设计中间成果，还需要“我”进一步通过“质疑”引入更多“质量属性”以及“特殊功能场景”来驱动后续的架构设计工作的开展。 在保留“需求驱动的架构设计”所有正确内涵的同时，“质疑驱动的架构设计” 告诉架构师:你的头脑，才是架构设计全过程的真正驱动力。 质疑意识，是架构师最宝贵的意识之一。 至于有的专家提倡的“用例驱动的架构设计”这种观点，则有严重缺陷，3句话足以揭示这一点: 需求=功能+质量+约束 用例是功能需求实际上的标准 用例涉及、但不涵盖非功能需求 "},"ch1/1.2.3.html":{"url":"ch1/1.2.3.html","title":"1.2.3. 多阶段还是多视图？","keywords":"","body":"1.2.3. 多阶段还是多视图？ 架构设计的多视图方法很重要，但是，架构设计方法首先当时多阶段的，其次才是多视图的。 一句话，先做后做--这叫阶段（Phase）,齐头并进--这叫视图(View)。 任何好的方法（不局限于软件领域），都必须以时间为轴来组织，因为这样才最利于指导实践。 架构设计只需要多视图方法，看上去很美，其实并不足够。实际上，大量一线架构师早已感觉到多视图方法的“不足够”。例如，想想投标： 一方面，投标时，需要提供和讲解《方案建议书》，其中涉及架构的内容。 另一方面，团队并行开发是，需要《架构设计文档》提供多方涉众使用。 但是，投标时将的“架构”和并行开发时做为基础的“架构”在同一个抽象层次上吗？绝不可能。前者叫“概念架构”，后者叫“细化架构”。 如果投标失败，细化架构根本没有必要做了。 结论，概念架构设计和细化架构设计，是两个架构阶段，不是两个架构视图。 "},"ch1/1.2.4.html":{"url":"ch1/1.2.4.html","title":"1.2.4. 内置最佳实践","keywords":"","body":"1.2.4. 内置最佳实践 方法不应该是个空框框，应融入最佳实践经验。相信业界很多专家都正朝着这个方向迈进。 ADMEMS方法融入了哪些实践？ 逻辑架构设计的10条经验 质疑驱动的逻辑架构设计的整体思路 基于鲁棒图进行初步设计的10条经验 ADMEMS矩阵方法 约束的4大类型 ... "},"ch1/1.3.html":{"url":"ch1/1.3.html","title":"1.3. ADMEMS方法体系:3个阶段，一个贯穿","keywords":"","body":"1.3. ADMEMS方法体系:3个阶段，一个贯穿 作为方法体系，ADMEMS方法通过3个阶段和一个贯穿，来覆盖“需求进，架构出”的架构设计完整工作内容。 上面的图基本上说明“3个阶段”在整个方法体系中的位置。 具体而言： 预备架构（Pre-architecture）阶段（简称PA阶段） 最大误区：架构师是技术人员不必懂需求 实践要点：摒弃“需求列表”方式，简历二维需求观 思维工具：ADMEMS矩阵等 概念架构（Conceptual Architecture）阶段（简称CA阶段） 最大误区：概念架构 = 理想架构 实践要点：重大需求塑造概念架构 思维工具：鲁棒图、目标-场景-决策表等 细化架构（Refined Architecture）阶段（简称RA阶段） 最大误区：架构 = 模块 + 接口 实践要点：贴近实践的5视图法 思维工具：包图、包-接口图、灰盒包图、时序图、目标-场景-决策表等 3个阶段之间的先后顺序是有极大实际意义，否则就不能称其为“阶段”了。 试想，在PA阶段对需求理解不全面（例如遗漏了需求）、不深入（例如没有发现“高性能”和“可扩展”是两个存在矛盾的质量属性），后续设计怎会合理？ 试想，CA阶段的概念架构设计成果没有反应系统的特点就“冲”去做RA设计，是不是比如会造成更多的设计返工？ “1个贯穿”，指的是对非功能目标的考虑。 "},"ch1/1.3.1.html":{"url":"ch1/1.3.1.html","title":"1.3.1. Pre-architecture阶段：ADMEMS矩阵方法","keywords":"","body":"1.3.1. Pre-architecture阶段：ADMEMS矩阵方法 PA阶段的使命，可以概况为一句话：全面理解需求，从而把握需求特点，进而确定架构设计驱动力。 其中，ADMEMS矩阵居于方法的核心。 "},"ch1/1.3.2.html":{"url":"ch1/1.3.2.html","title":"1.3.2. Conceptual Architecture阶段：重大需求塑造做概念架构","keywords":"","body":"1.3.2. Conceptual Architecture阶段：重大需求塑造做概念架构 概念架构 ≠ 理想化架构。 所以，必须考虑包括功能、质量、约束在内的所有方面的需求。 下图是推荐的概念架构设计的步骤。 "},"ch1/1.3.3.html":{"url":"ch1/1.3.3.html","title":"1.3.3. Refined Architecture阶段:落地的 5 视图方法","keywords":"","body":"1.3.3. Refined Architecture阶段:落地的5视图方法 细化架构是相对于概念架构而言的。 细化架构阶段的总体方法为5视图方法。 许多架构师，言架构必谈OO。在他们的思想里面，认为OO方法已经完整覆盖了架构设计的所有方法和技巧。这种看法，是相当片面的。 弱OO方法已涵盖架构设计的全部，那么5视图方法所涉及的逻辑架构、物理架构、开发架构、运行架构、数据架构，都应受到OO方法的指导，然而并不是这样。 上面图中说提到的物理架构、开发架构、运行架构和数据架构者4个架构视图，分别是面对节点、面对文件、面对控制流和面向Table（或文件）的 -- 也就是说，一般认为这4个架构摄图主要的思维并非OO思维。 另一方面，即使是逻辑架构的设计，也未必是以OO方法为指导的。应该将逻辑架构设计总结为 “面向职责” 更贴近本质。 "},"ch1/1.3.4.html":{"url":"ch1/1.3.4.html","title":"1.3.4 持续关注非功能需求:“目标-场景-决策”表方法","keywords":"","body":"1.3.4 持续关注非功能需求:“目标-场景-决策”表方法 非功能需求不可能是“速决战”，连编码都会影响到性能等非功能属性，更何况概念架构设计和细化架构设计。 ADMEMS方法应对非功能需求的思维工具，目标-场景-决策表可以将架构师的思维可视化出来。 "},"ch1/1.4.html":{"url":"ch1/1.4.html","title":"1.4. 如何解决“6大困惑”","keywords":"","body":"1.4. 如何解决“6大困惑” 那么，如何运用本书解决之前提到的“6个困惑”呢？ 如果，你是一个已经有一定实践经验的架构师，希望更加合理地对系统进行模块切分，请关注“第三部分 Refined Architecture阶段”。你将了解到，划分子系统的4大原则。 职责分离原则 通用专用分离原则 技能分离原则 工作量均衡原则 "},"ch2/":{"url":"ch2/","title":"第2章 Pre-architecture的故事","keywords":"","body":"第2章 Pre-architecture的故事 所谓的“开始就是结局”，要达到什么样的结局取决于什么样的开始，结局就是开始的地方。 -- T.S 艾略特，《四个四重奏》 需求验证的目标是尽可能的暴露问题，而不是证明无错。 -- 徐峰，《软件需求的最佳实践》 没有风险的软件早就比开发完了。 作为架构师，首先要面对的风险就是需求。既要关注功能需求，又要平衡互相矛盾的质量属性需求，还不能遗漏各方面的约束性需求...这，已经成为合格架构师必需的基本功。 接下来，3个真实故事都说明了这一点。 "},"ch2/2.1.html":{"url":"ch2/2.1.html","title":"2.1. “不就是一个MIS吗!”","keywords":"","body":"2.1. “不就是个MIS吗!” 2.1.1 故事： 外籍人员管理系统 公司接单了，一个市级的外籍人员管理系统。 小周被任命为这个项目的架构师。需求分析阶段，小周也参与了。几天之后，小周就开始“轻敌”了，他在一次项目会上说了这么一句话：“这个项目不就是一个MIS吗!” 接下来的工作比较顺利，项目组也算情绪高昂...... 项目组的情绪急转直下，出现在项目接近尾声的一天，客户方的小崔，看着漂亮的“外籍人员信息录入”界面，弱弱的说了一句，“哦，外籍人员的信息，大部分都不是我们录入的，而是来自省局。” 这些问题大了，最棘手的问题是，项目定义的数据库Schema和省级系统的数据库Schema不一致。 若飙车不一致状态，就人为造成了数据格式的不兼容，这是典型的烟囱式应用的做法，为未来可能出现的更多整合要求埋下了障碍； 若参考省级系统的数据模型重新定义数据库Schema，大量代码就必须重写，项目工期必然拖延。 拼命加班...... 2.1.2. 探究：哪些因素构成了架构设计的约束性需求 有人说：“错”的一半是“金”，“败”的一半是“贝”。 故事中暴露的问题看似简单：太大意了，遗漏了重要约束性需求。但试问：下次如何避免？...... 只有我们这样问自己，才算是“败”中求“贝”。 反思结果可以关注第4章 ADMEMS方法的‘约束性分类理论’ "},"ch2/2.2.html":{"url":"ch2/2.2.html","title":"2.2. “必须把虚拟缓存管理裁剪掉”","keywords":"","body":"2.2. “必须把虚拟缓存管理裁剪掉” 2.2.1 故事：嵌入式OS的裁剪 系统软件研究室的新任务启动了，对VxWorks操作系统进行裁剪，并开发专用硬件驱动程序。 团队成员都挺提劲的...... 这天，总工程师要听听进展情况，亲临研究室。当小吴开始汇报对OS虚拟内存管理的“深入理解”时，总工程师的标签有些不大自然。 不久，他打断了小吴，说了这么一句话：“整个系统才有多大内存可用？我们的OS占的内存越多，应用软件可用的内存就越少。所以，必须把OS的虚拟内存管理裁剪掉，直接访问物理内存。” 举“组”震惊，却又深表折服。 2.2.2. 探究：又是约束 架构设计不仅仅要考虑支持功能、满足质量要求，还要重视各种约束性需求。 这个故事中的“内存有限”，就是嵌入式系统设计中常见的约束。 关注约束，要趁早。 "},"ch2/2.3.html":{"url":"ch2/2.3.html","title":"2.3. “都是C++的错，换C重写”","keywords":"","body":"2.3. “都是C++的错，换C重写” 2.3.1. 故事：放弃C++，用C重写计费系统 老郑曾经挺开心。 老郑在某电信软件企业，负责计费系统的架构。最初，他非常重视系统的性能问题，因为他认为：电信领域用户群光，数据量大，所以性能的压力必然会很大。 后来，他们用C++开发的计费系统上线了，用户反映彼此，性能挺高的。 但现在，老郑很懊恼。 原因何在？原来，计费系统一直面临着功能不断改进的压力，整个团队不断致力于提高系统的可扩展性--以便于增加和修改功能。但始料未及的是，可扩展性上去了，性能下来了！ 看着程序里导出都是接口和无处不在的间接、继承，老郑产生了一个危险的念头，都是C++的错，应该用C重写计费系统！ 2.3.2. 探究：相互矛盾的质量属性 互动问题： 问题：某公司以C语言替代C++，重写电信计费系统，因为开发人员引入了太多抽象，导致“可扩展性上去了，性能下来了”。此法可行否？ A. 能解决问题 B. 于事无补，因为C也会过度设计 C. 问题出在Pre-Architecture D. 架构设计中必须分析质量之间的互相影响，制定权衡取舍策略 正确答案：B、C、D 高性能和灵活扩展这两个质量属性之间存在矛盾关系，这就是要害。 上面这张图揭示了更多质量属性之间的“促进”或“矛盾”关系。 我们可以看到：性能和安全性，与其他许多质量属性都是矛盾的。 正确的做法是： 在架构设计之初，就全盘考虑架构设计要重点关注关键质量目标--以老郑为例，性能和可扩展性（当然还会有其他质量属性）都重要。 在第一时间就判断这些“关键质量”之间有没有冲突关系，并制定权衡取舍策略--仍以老郑为例，性能和可扩展性矛盾，性能的优先级更高，谨慎评审提高可扩展性的设计对性能的影响后决定是否采用。 "},"ch2/2.4.html":{"url":"ch2/2.4.html","title":"2.4. 展望“Pre-architecture阶段篇”","keywords":"","body":"2.4. 展望“Pre-architecture阶段篇” 失败的故事，何止3个？透过这冰山一角，我们看到的是一线架构师“把握需求技能的缺失”。 软件架构师不必是需求捕获专家；但他一定应在需求分类、需求折中和需求变更的研究方面的专家，否则他和优秀软件架构师相比就输在“起跑线”上。 接下来，我们来考虑如何建立需求理解的大局观、如何把握需求特点、确定架构设计驱动力。 "},"ch3/":{"url":"ch3/","title":"第3章 Pre-architecture总论","keywords":"","body":"第3章 Pre-architecture总论 凡是预则立，不预则废。 -- 孔子，《礼记.中庸》 业内对架构的讨论沿用了传统思路：如果知道了系统需求，就可以此系统构建架构，这种观点是缺乏远见的...... -- Len.Bass 《软件架构实践（第2版）》 架构设计对系统成败非常关键，那么，什么对架构设计的成败非常关键呢？ 功能需求、质量属性及约束共同决定了架构，对这3类需求的把握是否到位、设计是否对路，是架构设计成败的关键所在！ 然而，业界的现状却是： “架构师就是技术高手”的声音充耳不绝，我们常错误地认为“架构师不必懂需求”。例如，许多不知道业务级需求、用户级需求、开发级需求包含的具体内容，更不懂功能、质量、约束对架构设计的影响如何大相径庭。 只有少数经验深厚的架构师在“拿到”需求之后，会基于业务背景、系统规模、技术趋势、开发团队现状等现实情况，对需求进行理性的、有针对性的权衡、取舍、补充、而在方法一级，Pre-architecture阶段基本是空白的。 期望能够在方法一级为“Pre-architecture阶段”提供较明确的指导。 核心的“四步法”： 需求结构化 分析约束影响 确定关键质量 确定关键功能 "},"ch3/3.1.html":{"url":"ch3/3.1.html","title":"3.1. 什么是Pre-architeture","keywords":"","body":"3.1. 什么是Pre-architecture 我认为，完整覆盖“需求进，架构出”的架构设计方法才是符合需要的。 Pre-architecture就是架构设计的最前期阶段，其工作目标包括：理解需求、建立需求大局观，确定架构设计方向等。 “磨刀不误砍柴工”。如果说“CA”阶段和“RA”阶段是“砍柴”（这两个阶段都对系统进行了某种程度的切分，系统已经不再是“黑盒子”了），那么最初的Pre-architecture阶段就是“磨刀”（此阶段未对系统进行切分，系统还是“黑盒子”）。 "},"ch3/3.2.html":{"url":"ch3/3.2.html","title":"3.2. 实际意义","keywords":"","body":"3.2. 实际意义 Pre-architecture阶段虽然是铺垫性质的阶段，但对架构实践而言意义重大。 3.2.1. 需求理解的大局观 架构师常常面对相互矛盾的需求目标。如果对需求的理解缺乏大局观，那将如何进行需求的权衡取舍？ 重大需求塑造概念架构。如果对需求的理解缺乏大局观，那将如何识别重大需求、特色需求、高风险需求？ Pre-archiecture阶段能帮助架构师建立需求理解的大局观。任何需求都可定位与业务级需求、用户级需求、开发级需求这3个需求层次的某一层，同时也必属于功能、质量、约束这3类需求的某一层。 如此一来，就便于梳理脉络、把握关系。 3.2.2. 降低架构失败风险 对需求理解不透、遗漏需求往往是架构设计失败的重要原因。在你的身边，一定有类似上一章3个真实故事那样的案例。 有一副软件行业自嘲的漫画，讲的是猴子希望得到一串香蕉，收到的却是骨头--这个礼物并不能满足它的真实需求。相信许多人看到这副漫画会苦笑不已。用户经常得不到真正满足他们需求的系统，这已成为整个软件业界一个严峻的问题。 我们无法回避的一个事实：架构师在需求的理解、权衡、取舍和补充这几方面能力严重不足。 从需求转入设计时，因为定制方案过程的复杂性，会激增出大量的衍生需求（针对一种特定设计方案的需求）。设计需求是原始需求的50倍之多。 Pre-architecture阶段将告诉大家，如何告别拙劣的“需求列表”方法（它难道不是遗漏架构影响因素的罪魁祸首吗？），取而代之以ADMEMS矩阵方法。 的确，需求是有结构的！由于ADMEMS的“二维需求观”体现了更复杂的、更本质的需求结构，所以可以帮助架构师更全面地看待需求、避免遗漏重要的非功能性需求，大大降低架构失败的风险。 3.2.3. 尽早开始架构设计 如何尽早开始软件架构设计？这是很多软件企业非常关心的一个问题，因为大家都深感工期的巨大压力。 灵活运用Pre-architecture阶段的方法，有一个额外的好处：能够在需求没有“全面完成”的情况下开始架构设计。 具体而言，为了尽早开始架构设计，软件企业必须做好以下两点： 让架构师参与需求分析工作 实际上，让架构师相对自由的“全程”参与需求分析工作--甚至可以不为任何具体的需求捕获、需求分析、需求文档工作负责 不能被动等待完善的产品需求 建议架构师在参与需求分析工作是，不断运用ADMEMS矩阵等工具对需求进行大局的梳理，只要满足下列3个条件，就可以尽早开始进行架构设计工作。 有了明确的业务需求。必须保证甲、乙双方就建设系统的目标（可能不止一项）达成共识，《愿景文档》经过了正式评审，并明确了投资、工期标准、整合等约束条件。试想，业务需求含糊不清，架构设计方向如何确定呢？ 了解全面的用户需求。也就是说，系统能帮助用户干什么、不能干什么，这个“需求的Scope”已经非常明确了。如果采用了用例技术，则表现为“用例图”是比较完善的，没有明显遗漏 注意用例图和用例规约在需求分析中的实践意义不同，可参考《软件架构设计》一书 有了典型的行为需求。这意味着，大量需求还未明确定义，离提交《软件需求规格说明书》还早。如果采用用例技术，则表现为核心功能的《用例规约》已定义。 3.2.4. 明确架构设计的“驱动力” 架构设计的“驱动力”不就是《软件需求规格说明书》吗？这种观点，只对了一半。 问题1：试想，《软件需求规格说明书》中几乎没有定义非功能性需求（客户也签字了），架构设计师就可以不考虑非功能性需求了吗？ 问题2：试想，需求变更难以避免，如果以所有需求作为架构设计的“驱动力”会是什么结果？ 问题3：试想，《软件需求规格说明书》中照抄了《ISO 9126》中所有的质量属性要求，架构师应该不计成本，不分重点的全部支持吗？ 上面是3个问题，都是日常工作中常见的问题，都说明架构师还需要关注其他很多因素，最终或添加、或减少、或折衷，理性的确定真正的架构设计“驱动力”。 具体而言，Pre-architecture阶段将告诉我们不辱使命的方法： 分析业务需求和约束背后的衍生需求--针对问题1. 发现遗漏需求--针对问题1. 确定关键功能--针对问题2. 确定关键质量--针对问题2. 权衡质量属性之间矛盾关系--针对问题3. "},"ch3/3.3.html":{"url":"ch3/3.3.html","title":"3.3. 业界现状","keywords":"","body":"3.3. 业界现状 既然Pre-architecture阶段如此重要，业界现状如何呢？ 很遗憾，业界对Pre-architecture阶段普遍不够重视。相反“架构设计唯靠经验”、“架构设计目标不变”等错误观点比较常见。 我们头脑中的“位置”是有限的，如果错误的认知占据了主导位置会导致实践偏差，必须防止。 3.3.1. “唯经验论” 和“架构师不必懂需求”的误解相比，“唯经验论”已经有所进步了。这种观点认为，架构师纯粹凭借经验，发现需求的遗漏、权衡需求之间的矛盾、确定架构设计的重点目标。 必须承认，经验对架构设计很重要，但“唯经验论”依然是错误的。 因此，世界上并不存在两个完全相同的想，不同的项目在功能需求、质量属性，以及约束这3方面必然存在差异。 于是，架构师不仅应具有一定经验，还必须掌握超越具体项目的、更具有意义的方法和技能。 3.3.2. “目标不变论” 架构设计的目标不是一成不变的，基于此认识，ADMEMS方法在Pre-architecture阶段的“确定关键质量”环境提供了专门的指导。 “架构设计目标不变论”是错误的。 例如，有人认为： 我们必须牢记架构设计的总体目标，可概况为以下几点。 最大化的重用...... 尽可能的简单明了...... 最灵活的扩展性...... 首先，若架构设计的目标真能概括为不变的“几点”，那可算是架构师的福音了。 但实际上，架构设计的目标必然会随着领域不同（如航天航空、电信、电子政务）、规模不同（如项目、产品、平台）、条件不同（如工期、预算、标准）而变化。 其次，为重用、简单、可扩展都加了“最”（而不是权衡折中），不符合架构设计的现实，更何况“灵活”和“简单”之间常常存在矛盾。 3.3.3. 需求分类法的现状 软件行业处在不断发展变化中，软件需求分类法就是一例。当前，业界影响最为广泛的需求分类法将需求分为3个层次。 图片来源：《软件需求》 这种需求分类法的最大好处是明确了不同层次之间的跟踪关系--业务需求->用户需求->功能需求。从而建立了需求分析的主要脉络，非常有意义。 但是对以架构师来说，这种需求分类法中的“约束条件”太过狭义了，没有反应“架构设计必须面对来自业务环节、使用环境、构建环境、技术环境的4大类约束”这一现实情况。 再例如，RUP提倡的需求分类法也包含3个层次：需要（Need）、特性（Feature）、软件需求。 这类分类法也是主要为需求分析工作服务的，它除了非常倚重用例技术之外，还有一个明显特点--Feature。 以特性（Feature）技术作为从需要（Need）想软件需求过过渡的跳板，是解决需求分析中“从需求想软件需求跨度过大”问题不错的选择，这一点已经受到很多实践者的认同。 但是，这个方法中用例的地位过分突出了，又由于“用例涉及但不涵盖非功能需求”的性质，不少实践者遗漏非功能需求的常见问题也就不难解释了。 最后，顺便指明上述两种“需求层次论”的对应关系，此问题令不少实践者困惑。 3.3.4. 需求决定架构的原理还需继续归纳 不懂不同需求分布如何影响架构，就难以进行理性的架构设计，难免“拍脑袋”决策，关于需求决定架构原理，业界当前的认知状况如下： 功能影响架构原理，研究的最透彻 质量影响架构的原理，也有基本共识 约束影响架构的原理在很大成图上被忽视了 "},"ch3/3.4.html":{"url":"ch3/3.4.html","title":"3.4. 实践要领","keywords":"","body":"3.4. 实践要领 问题是方法之父。不怕有问题，就怕发现不了问题。 3.4.1. 不同需求影响架构的不同原理，才是架构设计的基础 当前业界，大多数架构师都认同“需求决定架构”，但对需求“如何决定”架构还知之不深。 请各位架构师问自己这样一个问题：需求决定架构，真的是这么简单吗？ 如果真的这么简单，为何“我”常常对需求已“心知肚明”，却依然对架构设计“一筹莫展”呢？ 答案是：“需求决定架构”是对的，但不同需求影响架构的不同原理，才是架构设计思维的基础。 “人类知识和人力权利归于以：因为凡是不知原因时，即不能产生结果。......而凡是在思辨中为原因者在动作中则为法则。” -- 哲学家培根 任何一项功能都是有一条特定的“职责协作链”完成的。 作为完整的软件系统，它在支持每一个具体功能时，都必然涉及软件不同“部分”之间的相互配置。系统控制权在这些不同的“部分”之间的来回传递，形成一条“职责协作链”，可以完成非常复杂的功能。 而质量，是完善架构设计的驱动力，不考虑质量的系统是无法走出实验室的。 基于中间设计成果进一步质疑是其中基本的“思维方式” 例如：如果只考虑功能，“页面缓存”的设计就永远不会被引入，它是质疑性能、调整设计的结果。 至于约束，则有不同的具体方式影响着架构设计 直接制约设计决策的约束。例如，“系统运行与Unix平台之上”作为一条约束，架构师直接遵守即可。 转化为功能需求的约束。例如，“本银行系统必须严格执行人民银行统一规定的利率”是一条约束，但分析后发现，正是它引出了一条功能需求：即必须提供调整利率设置的实用功能。 转化为质量属性需求的约束。例如，有经验的系统分析员发现了一条重要约束：“任职于各储蓄所和分理处的柜员，计算机水平普遍不高”。由此，未来的系统必须具有很高的易用性（否则不会用）和鲁棒性（否则可能会把系统搞瘫痪了）就非常必要了。 3.4.2. 二维需求观 观念是行为的向导，有什么样的观念存在，就有怎样的行为方式产生--突破拙劣观念的意义就在于此。 作为架构师，如果在你的观念中，需求是一个散乱无序的“列表”，面对复杂系统时就会非常被动。需求列表这种贴着“简单”这个“招人待见”标签的方法以及影响、并正在继续影响着许多一线架构师。 3.4.3. 关键需求决定架构，其他需求验证架构 有经验的架构师，懂得在实践中运用“关键需求决定架构”的理念。 功能需求做减法。在所有功能中挑选一个“关键功能子集”，作为“架构设计驱动力”的第一部分。 质量需求做减法。根据系统所在领域特点及系统规模等因素，确定架构设计重点支持哪些质量属性，作为“架构设计驱动力”的第二部分。 约束需求做加法。充分考虑需求方及业务环境因素、用户群及使用环境因素、开发方及构建环境因素、业界当前技术环境因素等“4类约束”，将之作为“架构设计驱动力”的第三部分。 3.4.4. Pre-architecture阶段的4个步骤 Pre-architecture阶段对整个架构设计工作非常重要，它担负着建立需求大局观、把握需求特点、确定架构设计驱动力的责任。 首先，将多而杂的架构影响因素梳理脉络、建立全面有序的理解。 然后，分别针对约束、质量、功能这3类需求开展相应工作。 分析约束影响，识别隐含需求 确定关键质量，明确关键质量之间的优先级 确定关键功能，便于更有针对性的分配有限的架构设计时间 "},"ch4/":{"url":"ch4/","title":"第4章 需求结构化与分析约束影响","keywords":"","body":"第4章 需求结构化与分析约束影响 “心念不同，判断力自然不同。” -- 严定道，《格局决定结局》 全面认识需求，是生成出高质量软件所必须的“第一项修炼” -- 温昱，《软件架构设计》 Pre-architecture阶段包括4个步骤，咱们先讲讲前两步。 第1步，需求结构化 第2步，分析约束影响 "},"ch4/4.1.html":{"url":"ch4/4.1.html","title":"4.1. 为什么必须进行需求结构化","keywords":"","body":"4.1. 为什么必须进行需求结构化 需求是有结构的。 许多实践者不懂这一点，更不知道如何“主动运用”这一点。在他们眼中，架构设计要应对的需求往往是又多又乱的，而且遗漏了关键需求也发现不了...... 相反，有经验的架构师懂得运用需求的结构。他们能够将复杂的需求集合梳理得紧紧有条，为进一步分析不同需求之间的联系（作为权衡折中的依据）、识别遗漏的重要需求打下坚实基础。 Pre-architecture阶段要求进行需求结构化，这代表着ADMEMS方法更贴近一线架构设计的真实实践。 通过形象的“物体归类”的隐喻可以嘉盛对需求结构化工作的理解。 "},"ch4/4.2.html":{"url":"ch4/4.2.html","title":"4.2. 用ADMEMS矩阵方法进行需求结构化","keywords":"","body":"4.2. 用ADMEMS矩阵方法进行需求结构化 那么，需求结构化要怎么做呢？ 决不能认为《软件需求规格说明书》就是需求的全部 运用ADMEMS矩阵方法 4.2.1. 范围：超越《软件需求规格说明书》 首先，需求文档常常不够全面，所有有经验的架构师都重视需求文档，但不应该“唯需求文档论”。 其次，需求变更经常发生，“依赖且仅依赖需求文档”不够聪明，使架构设计工作非常被动。 既然架构师必须“对需求进行理性的、有针对性的权衡、取舍、补充”，那么“作为架构设计驱动力的需求因素”和“供甲方确认的《软件需求规格说明书》”之间就必然不能“划等号”。 所以，架构师要通过需求结构化真正全面的“鸟瞰”需求大局，就必须超越《软件需求规格说明书》 还有一个重大意义在于，只有摆脱了对《软件需求规格说明书》的“呆板依赖”，才有可能尽早开始架构设计（参见3.2.3. 尽早开始架构设计）。 4.2.2. 工具：ADMEMS矩阵 矩阵，是很多著名方法的核心。 例如：制定公司层战略的方法之一是“波士顿矩阵”，“波士顿矩阵”又称为“市场增长率-相对市场份额矩阵”。 “ADMEMS矩阵”，也称为“需求层次-需求方面矩阵”。 需求层次分析和解释 业务级需求：包含客户或出资者要达到的业务目标、预期投资、工期要求、以及要符合哪些标准、对哪些遗留系统进行整合等约束条件 用户级需求：用户使用系统来辅助完成哪些工作？对质量有什么要求？用户群及所处的使用环境有什么特殊要求? 开发级需求：开发人员需要实现什么？开发期间、维护期间有什么质量考虑？开发团队的哪些情况会反过来影响架构？ 需求的三个层次，是站在“不同层次的涉众提出需求所站的立场不同的角度”，将需求划分为三种类型。 另外，需求还需要从不同的方面进行考虑。 例如，一个网上书店系统的功能需求可能包括“浏览书目”、“下订单”、“跟踪订单状态”、“为书籍打分”等，质量属性要求包括“互操作性”和“安全性”等，而“必须运行在Linux平台之上”属于约束性需求。 忽视质量属性和约束性需求，常常导致架构师设计最终失败。 从“需求定义了直接目标还是间接限制”的角度，把需求划分为3中类型，这就是需求的3个方面： 功能需求：更多体现各级直接目标要求 质量属性：运行期质量 + 开发期质量 约束需求：业务环境因素 + 使用环境因素 + 构建环境因素 + 技术环境因素 一句话，需求是有结构的。而且，需求的结构绝不是“List”，而应该是“二维数组”。 结构化是控制复杂度的好办法。 进行需求结构化之后，会感觉“需求变少了”--其实，需求并没有变少，但复杂度却得到了控制。 另外，进行结构化之后，最大的好处是，可以比原来更轻易发现遗漏需求。 方法的运用，可以参考4.7. 大型B2C网站案例：需求结构化与分析约束影响 "},"ch4/4.3.html":{"url":"ch4/4.3.html","title":"4.3. 为什么必须分析约束影响","keywords":"","body":"4.3. 为什么必须分析约束影响 风险有个烦人的特点：一旦你忘了它，它就会找上门来制造麻烦。 背鳍下面是不是一条鲨鱼？约束性需求中，是不是潜藏了风险因素？ 对于架构设计而言，来自方方面面的约束性需求中潜藏着大量风险因素。 "},"ch4/4.4.html":{"url":"ch4/4.4.html","title":"4.4. ADMEMS方法的“约束分类理论”","keywords":"","body":"4.4. ADMEMS方法的“约束分类理论” 分析约束影响应该怎么做？ 我们先看看这些约束来自“哪些涉众”？ 4类约束在ADMEMS矩阵中的位置清楚表明：业务环节、使用环境、构建环境应分别考虑客户、用户、开发者3类涉众，而技术环境与上述3类涉众都有关系 ADMEMS矩阵参见4.2.2 用ADMEMS矩阵方法进行需求结构化-工具：ADMEMS矩阵 只有把握住涉众来源，才便于发现并归纳涵盖广泛的约束因素，也有利于针对性地进行交流，还可跟踪对约束的支持是否令涉众满意。 第一，来自客户或出资方的约束性需求 架构师必须充分考虑客户对上线时间的要求、预算限制，以及集成需要等非功能需求。 客户所处的业务领域是什么？有什么业务规划和业务限制。 是否需要关注相应的法律法规，专利限制？ ...... 第二，来做用户的约束性需求 软件将提供给何阶层用户？ 用户的年龄段？使用偏好？ 用户是否遍布多个国家？ 使用期间的环境有电磁干扰、车船移动等因素吗？ ...... 第三，来自开发者和升级维护人员的约束性需求 如果开发团队的技术水平有限（有些软件企业甚至希望通过招聘便宜的程序员来降低成本）、磨合程度不高、分布在不同的陈那个是，会又和影响？ 开发管理方面、源代码保密方面，是否需要涉及？ ...... 第四，也不能遗忘，业界当前技术环境本身也是约束性需求 技术平台、中间件、编程语言等的流行性认同度、优缺点等。 技术发展的趋势如何？ ...... 架构师应当直接或（通过需求分析员）间接的了解和掌握上述需求和约束，并深刻理解它们对架构的影响，只有这样才能设计出合适的软件架构。 例如，如果客户是一家小型超市，软件和硬件采购的预算内都是很有限，那么你就不宜采用依赖太多昂贵中间件的软件架构设计方案。 "},"ch4/4.5.html":{"url":"ch4/4.5.html","title":"4.5. Big Picture:架构师应该这样理解约束","keywords":"","body":"4.5. Big Picture:架构师应该这样理解约束 另外，还有一个重要的基础问题，太多的架构师对约束的理解都过于零散，影响了系统化思维。 一句话：约束是架构设计的上下文。 没有全局观念就不可能成为架构师，”约束是架构设计要解决的问题的上下文“是一个犀利的理解，揭示了 ”软件需求 = 功能需求 + 质量 + 约束“背后更深层层次的规律。 如果忽视了上下文对架构设计的限制，最终的架构设计就是不合理的，甚至是不可行的。 举个生活中的例子--设计大桥。建筑师必须关注以下4类约束的影响，合理规划大桥的设计方案。 考虑商业环境因素：以促进两岸的经济交往为主（这会影响大桥的选址），同时也希望大桥在建设在一定程度上起到提升城市形象的作用。 考虑使用环境因素：水上交通繁忙，二期常有大吨位船只通过，大桥建成投入使用期间不能对此造成影响。 考虑构建环境因素：这是一条很大的河流，水深江阔，为造桥而断流几个月是绝对不可行的。 考虑技术环境因素：斜拉桥因其跨度大等优点，当前广为流传，并且技术也相当成熟...... "},"ch4/4.6.html":{"url":"ch4/4.6.html","title":"4.6. 用ADMEMS矩阵方法辅助约束分析","keywords":"","body":"4.6. 用ADMEMS矩阵方法辅助约束分析 分析约束影响在需求结构化的基础上，充分考虑需求方及业务环节因素，用户群及使用环境因素、开发方及构建环境因素、业界当前技术环境因素等”4类约束“，并分析约束印象、识别约束背后的衍生需求。 从本质上讲，分析约束影响就是分析各个需求项之间的关系，并发现被遗漏的需求。所以将需求”化杂乱为清晰“的正交表可以作为分析约束影响的基础--即在需求项清晰定位的前提下，找到不同需求之间的关系，发现遗漏需求。 ADMEMS矩阵方法应用法则有两个。 推导法则：从上到下，从右到左。 查漏法则：重点是质量属性遗漏。 "},"ch4/4.7.html":{"url":"ch4/4.7.html","title":"4.7. 大型B2C网站案例：需求结构化与分析约束影响","keywords":"","body":"4.7. 大型B2C网站案例：需求结构化与分析约束影响 "},"ch4/4.8.html":{"url":"ch4/4.8.html","title":"4.8. 贯穿案例","keywords":"","body":"4.8. 贯穿案例 "},"ch6/":{"url":"ch6/","title":"第6章 概念架构的故事","keywords":"","body":"第6章 概念架构的故事 胜兵先胜而后求战，败兵先站而后求胜。 -- 孙子，《孙子兵法 . 形篇》 人们常常使用战术，而忽略了战略。战略要求从大局上把握整个架构与设计......架构错误的代价非常高。 -- Stephane Faroult, 《SQL语言艺术》 架构新手和有经验的架构师的区别之一，在于是否懂得，并能有效的进行概念架构设计。作为架构新手，尤其害怕碰到自己没有做过的系统：系统较大时，一点祭出“架构 = 模块 + 接口”的发布却不太奏效，架构新手就往往乱了阵脚。想法，有经验的架构师不会一上来就关注与如何定义“接口”，他们在大型架构设计的早期比较注重识别重大需求、特色需求、高风险需求，据此来设计概念架构。 另外，概念架构设计还是投标及售后工作的有力武器。金牌售前和普通售前的一个重要区别是，能否清晰的讲解概念架构，并借此说明 “客户关系的价值如何实现、担心的问题如何解决”。 接下来，通过两个发生在身边的故事，来一窥上述不同工作（架构设计、投标、售前）背后的幕后英雄--概念架构。 "},"ch6/6.1.html":{"url":"ch6/6.1.html","title":"6.1. 一筹莫展","keywords":"","body":"6.1. 一筹莫展 日落西山，夜幕徐徐降临，遍布这个城市各个角落的写字楼陆续亮起了灯...... 灯下，有我们这些软件从业者加班的身影。小张，还有老王，就是故事的主角。 6.1.1. 小张，以及他负责的产品 加班人： 小张 职业概况： 28岁，某医疗软件公司的程序高手，这不，公司刚刚提拔他作了架构师。 加班缘由： 他正负责一个名为“合理用药监测系统（Prescription Automatic Screening System, PASS）”的软件的架构设计。由于以前没有做过类似的产品，小张压力很大。按说，压力大对软件行业的人来说早已是家常便饭了，但要命的是，小张有点不知所措了..... 晚上7点，小张坐在桌前。 在心中，小张对架构的理解可以概况成一个公式：“架构 = 模块 + 接口”。 成为架构师伊始，他还专门用“接口”和“架构”作为关键词在网上搜了一把，看看别人的观点是否和他相同。结果让他非常满意，网上的一些观点和他的观点惊人的像是。例如网上有观点认为： “当你发现可以越来越灵活的使用接口时，那么你就从程序员升级成架构师了。 在一些大型项目或大型公司里，都有架构师编写出系统接口，具体的实现类交给程序员编写。公司越大，这种情况月明显，所以在这些公司里做开发，我们可能都不知道编写出的系统是个什么样子，每天的工作可能就是做‘填空题’了” 但是，小张注定要在这个加班的夜晚，悄然开始重新认识“架构 = 模块 + 接口”这句话了。 一方面，小张已在“模块 + 接口”一级做了些设计努力。另一方面，小张也感觉到问题所在了：这个PASS系统未来不可能仅仅包含一个可执行单元！相反，医生需要的功能要嵌入医院信息管理系统（HIS系统）的医生工作站中，管理员的功能需要其他方式，Server要独立出来...... 小张当下的感觉，应了一句小品台词--“有点乱了”。是呀，连PASS系统到底将包含几个”可执行单元”都没有搞清楚，就考虑“模块 + 接口”一级的设计，的确有些武断了。 晚9点，思路不畅的小张开始上网搜资料。 在网上搜资料时，小张总是相当有耐心。他深知，虽然网上的资料非常多，但真正能启发思路的资料往往只在最后时刻出现。 小张移动鼠标，右击任务栏上的“浏览器”按钮，点击了“关闭组”菜单，者表示小张任务查到的资料启发不大，准备重头来过--在今晚已经是第3次了。 他若有所思，在搜索框中输入了3个关键词：”架构“、”大局“、”不拘小节“。一篇博文引起了他的注意： 概念性架构就是对系统设计的最初构想，就是把最关键的设计要素和交互的机制确定下来，然后考虑具体技术的运用，设计出实际架构。 概念性架构应该抓大局、不拘小节。 虽然概念性架构都跳不出”架构 = 组件 + 交互“的基本定义，但它们描述架构的具体方式还是有比较大的差异：有的重视逻辑层，有的重视物理层，有的通过隐喻表明机制，有的看起来似乎就是一些设计元素的组合。不同的概念性架构图中，“连接”代表的含义千差万别：有的是依赖方向，有的是控制方向，有的是数据流向，一次，必须根据具体情况而定。 小张仔细的揣摩每句话的意思。 不知不觉，时钟指向了11点，小张坐不住了。 他在办公室来来回回的踱步，表情时而郁闷，时而欣喜...... 最后，小张把文章打印了一份，塞在包里，离开了办公室。 6.1.2. 老王，后天见客户 加班人： 老王 职业概况： 35岁，某电信软件企业网管软件事业部的售前工程师。老王从事软件行业有10年了，一直做软件开发，一年前开始做售前相关工作。 加班缘由： 后天，他要到客户单位，做网管软件新产品的介绍。这个客户非常重要，二期公司对这一单志在必得，老王不敢懈怠。 老王看着公司草草拼凑出来的售前PPT有点发愁，架构方面的描述主要就是一个概念架构图，如图所示，这种架构描述根本没有体现产品特点，叫做售前的如何说服客户呢？ “我要不说明，谁看了这个概念架构能知道它是个网管系统，而不是电子商务或其他什么系统？”老王愤愤的想。 "},"ch6/6.2.html":{"url":"ch6/6.2.html","title":"6.2. 制定方针","keywords":"","body":"6.2. 制定方针 小张，还有老王，昨天都加班到很晚，但今天他们依然按时来到单位。 每天的太阳都是新的。对开朗的人来说，昨天的烦恼不算什么，根本不会影响他们今天工作的热情和创造力。 6.2.1. 小张：我必须先进行概念架构的设计 小张在座位上坐定，破例没有查收邮件，更没有上网看新闻。他做的第一件事是，拿一张干净的A4纸铺在桌上，开始逐条例举PASS系统需求中对架构产生最关键影响的“5大因素”。 “我作为架构师应该做什么呢？”小张脑中快速的思考着，“是一层不变的继续‘模块 + 接口’一级的设计，还是先针对主要风险确定架构大局，而后在进一步考虑它呢？” 经过一系列的反思，小张认为对PASS系统直接进行“模块 + 接口“一级直接进行合计存在以下两个严重的问题： 针对”单独的可执行单元“形式的系统，或许可以直接按”模块 + 接口“方式展开架构设计，而现在的PASS系统显然不是。 如何通过模块切分和接口定义来支持团队开发，还算不上当前的主要矛盾；上面分析的”5大因素“才是当前的主要矛盾。 主要矛盾决定事态发展。想清楚了架构设计的主要影响因素，小张微微有些高兴。他认真的把他的决定写在笔记本上（还特意加了一句注解说明），生怕忘了似的： 首先根据对架构产生最关键影响的”5大因素“进行概念设计。 注：概念架构不关心明确的接口定义。 此时的小张俨然像是在战场上做出了重大战略决策的将军。 6.2.2. 老王：清晰的概念架构，明确的价值体现 9点整，老王悠悠的走进办公室。他总是如此准时，在这个经常堵车的城市，可算是一个小小的迷了。 他做的第一件事是，往茶杯里放入了几十粒上好的枸杞，倒上开水。上午枸杞，下午绿茶，老王习惯了。老王就是有这个本事，根本看不出来昨晚加班是多么的一筹莫展。老王或许不知道，这种弄闲庭信步的气质恰恰是他日后越来越成功的关键。 温伯格讲：“力量是一种关系”。老王很欣赏这句话。 音乐有力量吗？不一定！它可以“催”人泪下，但也可以是对“牛”弹琴。 你的产品很好吗？不一定！只有满足客户需求的产品才是好的产品，所以做售前的决不能自我感觉良好。 胜利远远还没有”在望“，但端着茶杯楞一会儿神儿的老王已成竹在胸。 后天的重点不是在讲纯技术，而是抓住客户关系的价值和担心的问题，并在一个小时之内清晰的勾画出产品的相应策略。 "},"ch6/6.3.html":{"url":"ch6/6.3.html","title":"6.3. 柳暗花明","keywords":"","body":"6.3. 柳暗花明 行必果，小张和老王忙开了。 有人说，”行动果断是一种美德。“，其实，他们都觉得”行动果断“算不上什么美德，毕竟，老板是要看结果的--不行动，就永远没有成功的可能。 6.3.1. 小张：重大需求塑造概念架构 小张将”分析需求特点“所归纳出来”5大因素“作为概念架构设计的目标。 考虑设计目标中的1、2和3这三点，小张得到了概念架构中间结果。 接下来，小张继续深入概念架构的设计。他想：上述设计目标中的第4点和第5点还没有相应的对策，这无疑意味着具体的风险，因为从现在的设计来看根本无法做到“较高的持续可用性”。而对于”降低HIS系统差异带来的影响“也没有任何针对性的设计决定。 经过一番考虑之后（具体思考过程请参考”目标-场景-决策表“方法的讲解），小张做出了下面的概念架构设计决定。为了提高持续可用性，在设计中引入了故障转移集群。 针对”现行HIS系统差异很大、实现技术不统一“的约束性需求，重点考虑了如何提高重用性以降低开发及维护成本。采用的策略是：引入独立于具体HIS意思工作组的”PASS系统医生模块通用SDK“，它包括了”嵌入到医生工作站的软件模块“的所有特定HIS系统无关部分，使支持HIS的工作量降到最低。 6.3.2. 老王：概念架构体现重大需求 首先，老王通过一些途径了解了客户对网管软件采购的具体要求，例如可升级性、可方便支持新设备等。 接下来，老王从公司的服务器上下载了新的网管产品的各种文档，开始快速浏览。他在找售前材料商遗漏的，却至关重要的产品特色。他敏感的发现，有如下几点比较重要： 强大的API支持，便于二次开发。 基于SPI（服务编程接口）的可扩展设计。 最终，老王利用FAB分析法，轻车熟路的绘制了更能体现新网管产品价值的概念架构。此架构对客户关系的”可升级性、可方便支持新设备“等要求有着较明确的支持。 "},"ch6/6.4.html":{"url":"ch6/6.4.html","title":"6.4. 结局与经验","keywords":"","body":"6.4. 结局与经验 天气，风和日丽。 小张和老王的心情都特别好。虽然统计数据显示，这个城市一年有上百天都是蓝天，但他两总觉得今天的天蓝的特别漂亮。 6.4.1. 小张：概念架构时设计大系统的关键 小张负责的PASS产品成功上市了，市场反映很不错。 回顾过往的辛苦，小张觉得很有收获，特别是切实体会到了概念架构设计对大系统成败的关键作用。他的工作笔记，也因此备受珍爱，其中一页写到： 万事开头难。 当要设计的软件系统非常复杂时，直接设计实际架构往往有困难。实际的软件架构设计过程是，一部应先进行概念架构的设计，把嘴关键的设计要素和交互机制确定下来，概念架构是对系统设计的最初构想，但绝不是无关紧要的；相反，它对大型系统的成功非常关键。架构师在设计概念架构时，必须牢牢抓住重大需求、特色需求、高风险需求，有针对性的确定设计策略。 反过来讲，一个产品与类似产品在架构上的不同，其实在概念架构设计时就大局已定了。 概念架构一级的设计更重视”找对路子“，它往往是战略而不是战术，它必将策略化而未必全面，它必将强调重点机制而不一定非常完整。 在概念架构设计中，不关注明确的接口定义；之后才是”模块 + 接口“一级的设计。对大型系统而言，这一点恰恰是必需的。 6.4.2. 老王： 概念架构是售前必修课 老王成功了，最终这家客户采购了老王所在公司的新一代网管软件。 回顾这看似平常的一单，老王不无收获： 第一，概念架构是售前的必修课，所谓金牌销售，必备的能力之一是：是否能清晰的讲解概念架构，并借此说明”客户关系的价值如何实现，担心的问题如何解决“。 第二，成功的售前必须关注客户。力量是一种关系，通过FAB分析法找到产品之于客户的价值所在，是售前准备的重点之一。 第三，售前PPT不能千篇一律。作为公司，制作标准的售前PPT是为了避免一般售前人员不得要领，或者讲错理念，真正的专家级售前不应受到”标准售前PPT“的限制。 "},"ch7/":{"url":"ch7/","title":"第7章 Conceptual Architecture总论","keywords":"","body":"第7章 Conceptual Architecture总论 ”Use Case驱动“的观点既有积极意义，也有不利影响。从积极的方面看，Use Case这种需求描述方式确实有助于分析模型，设计模型，实现模型和测试模型的建立.....但是从另一方面看，OOSE对Use Case的依赖程度超出了它的实际能力。 -- 邵伟忠， 《面向对象的系统设计》 顶级设计者在设计中并不是按部就班地采用自顶向下（或自底向上）的方法，而是着眼于权重更大的目标。这些目标通常是难点问题，设计者不能轻易地看出这些问题的解决方案。为了得到整个的设计方案，设计者必须先致力于难点的设计并消除其中的疑惑。 -- Robert L. Glass, 《软件工程的事实与谬误》 概念架构是大型系统架构设计成本的关键。 "},"ch7/7.1.html":{"url":"ch7/7.1.html","title":"7.1. 什么是概念架构","keywords":"","body":"7.1. 什么是概念架构 下面是宏伟的金门大桥，这么复杂的架构，桥梁架构师是怎么“开始设计”的呢？ 答案是：概念架构（Conceptual Architecture）。下图展示了斜拉桥的概念架构示意图。由此图可以看出，概念架构高屋建瓴的给出高层解决方案：索塔负责承重，斜拉索吊起刚性梁。 下面，来看看软件行业（来自Dana Bredemeyer等专家）中概念架构的定义： 概念性架构界定系统的高层组件，以及它们之间的关系。概念性架构意在对系统进行适当分解，而不陷入细节。借此，可以与管理人员、市场人员、用户等非技术人员交流架构。概念性架构规定了每个组件的非正规约及架构图，但不涉及接口细节。(The Conceptual Architecture identifies the high-level components of the system, and the relatiooonships among them. Its purpose is to direct attention at an appropriate decomposition of the system without delving into details. Moreover, it proovides a useful vehicle for coommunicating the architecture to non-technical audiences, such as management, marketing, and users. It consists oof the Architecutre Diagram (without interface detail) and an informal component specification for each component.) 根据定义，我们注意到如下几点： 概念架构满足“架构 = 组件 + 交互”的基本定义，只不过概念架构仅关注高层组件(high-level components)。 概念架构对高层组件的“职责”进行笼统的界定（informal specification），并给出了高层组件之间的相互关系(Architecture Diagram)。 概念架构不应涉及接口细节(withouot iinterface detaiil)。 "},"ch7/7.2.html":{"url":"ch7/7.2.html","title":"7.2. 实际意义","keywords":"","body":"7.2. 实际意义 不同的系统架构经常不同。但请继续追问自己两个极具价值的问题。 不同系统的架构 ，为何不同？ 架构设计中，应何时建立架构大方向的不同？ 第1个问题的答案：需求不同，所有架构不同；当然，“需求”不是单指“功能需求”，而是包含了功能、质量、约束等方面。 第2个问题的答案：进行概念架构设计时应确立架构大方向。架构设计跪在有针对性，概念架构针对重大需求、特色需求、高风险需求的要求，给出高层次的解决方案--这就是概念架构最重要的意义。 另外，所谓“备选架构方案”经常是概念架构一级的，有助于架构的对比分析、评审优化。 最后，概念架构为投标、售前、市场宣传等工作提供强力支持，所以，概念架构也是售前和市场人员的“必修课”。 "},"ch7/7.3.html":{"url":"ch7/7.3.html","title":"7.3. 业界现状","keywords":"","body":"7.3. 业界现状 7.3.1. 误将“概念架构”等同于“理想架构” 主动思考以下两种说法是否正确： 架构设计是功能需求驱动的，对吗？ 架构设计是用例驱动的，对吗？ 说法1，错误。因为，架构设计的驱动力 = 功能 + 质量 + 约束。 说法2，同样错误。用例技术是功能需求实际上的标准，用例技术涉及，但无法全面涵盖非功能需求。所以，说法2和说法1并无本质区别。 因此，“用例驱动的架构设计”的做法颇值得商榷。纵观业界，有不少书持“用例驱动的架构设计”的观点。比如《Rational 统一过程：实践者之间》一书中有一节名为“是用哪个架构重要用例来驱动架构设计”，其中写道： 对架构重要的用例驱动了架构设计。对于大多数系统而言你通过选择仅仅20%至30%的用例，然后设计、实现并测试每个用例的一两个场景，就能降低大部分技术风险，并驱动欧诺个架构的实现。为了实现某个特定用例，你要识别出那些支持用例的软件元素。 实际上，实践者误认为概念架构就是只考虑功能设而设计出来的理想化架构，其实，这是关于概念架构的最大误解，在实践中应当注意避免。 7.3.2. 误把“阶段”当做“视图” “视图”是架构领域的热门词汇，但很不幸，“视图是个筐，什么都往里面装” -- 我们的同行经常犯这种错误。例如，《编程匠义 -- 编写卓越代码》一书中错误的认为： 概念视图，有时候也称为 “逻辑视图”，这种视图显示了系统的主要部分以及它们之间的相互关系。 再例如，一种称为“4视图法”的架构设计方法在业界有一定影响，该方法也误把“概念架构”当成了“概念架构视图”。 其实，视图与视图之间必须是并列的关系，是一种并行思维关系。概念架构不可能与“模块 + 接口”一级的设计并列。概念架构不是一个“架构设计视图”。 正确的做法是，概念架构是一个“架构设计阶段”，必须在细化架构阶段之前，针对重大需求、特殊需求、高风险需求，形成稳定的高层架构设计成果。 阶段之于方法的意义和视图大不相同： 阶段是先后关系，视图是并列关系，这其中有本质区别。 不同阶段解决不同层次的问题--概念架构确定架构设计的大方针。 阶段应该与明确的里程碑想对应--概念架构确定的是高层分割方案及其他重要决策是否合理？ "},"ch7/7.4.html":{"url":"ch7/7.4.html","title":"7.4. 实践要领","keywords":"","body":"7.4. 实践要领 很多有经验的架构师已经意识到概念架构的重要性，却缺乏理性方法的指导。我们来讲讲ADMEMS方法Conceptual Arch阶段的核心理念和3个步骤。 7.4.1. 重大需求塑造概念架构 ADMEMS方法Conceptual Arch阶段的核心理念： 重大需求塑造概念架构，这里的“重大需求”应涵盖功能需求、质量及约束3来需求中的关键部分。 概念架构针对重大需求、特色需求、高风险需求，给出高层次解决方案 问题1： 过于理想化 问题2： 未来修改很大 如果只考虑“功能需求”来设计概念架构，将导致概念架构沦为“理想化架构”，这个脆弱的架构不久就会面临“大改”的压力，甚至直接导致投标等工作失败。 7.4.2. 概念架构阶段的3个步骤 概念架构设计分为3个步骤： 初步设计：基于关键功能，借助鲁棒图进行以发现职责为目的的初步设计。这一步并不总是需要，但对于架构师而言，是“新系统”就必须重视这一步。 高层分割：对系统这个黑盒子进行高层切分，例如切分复杂系统为多个二级系统，或者直接切分系统为具体子系统。 考虑非功能需求：概念架构 ≠ 理想化架构，所以不仅要考虑功能，也必须考虑非功能。 "},"ch8/":{"url":"ch8/","title":"第8章 初步设计","keywords":"","body":"第8章 初步设计 好的开始是成功的一半。 -- 谚语 所谓鲁棒性分析时这样一种方法： 通过分析用例规约中的事件流，识别出实现用例规定的功能所需要的主要对象及其职责，形成以职责模型为主的初步设计 -- 温昱，《软件架构设计》 Conceptual Architecture阶段包含3个步骤： 第1步，初步设计。 第2步，高层分割。 第3步，考虑非功能需求。 "},"ch8/8.1.html":{"url":"ch8/8.1.html","title":"8.1. 初步设计对复杂系统的意义","keywords":"","body":"8.1. 初步设计对复杂系统的意义 初步设计并不总是必须的 -- 架构师只有在设计复杂系统时才需要它。 另外，“复杂”与否还和“熟悉”程度有关系。一个“很小”的系统涉及你未接触的领域，你会觉得它复杂的；一个“较大”的系统，但你有很具体的经验，你依然会觉得它“Just so so”。 初步设计的目标简单而明确：那就是发现职责。初步设计无须展开架构设计细节，否则就背上了“包袱”，这是复杂系统架构设计起步时的大忌。正如“初步设计”这个名字所暗示的，它只是狭义的架构设计的“第一枪”--之前的Pre-Architecture阶段并未对“系统”做任何“切分”。 “初步设计”这个名字还暗示我们，后续的架构设计工作必须以之为基础。具体而言，初步设计识别出了职责，后续的高层分割方案才能有依据，因为每个“高层分割单元”都是职责的承载体，而分割的目的也恰恰在于规划高层职责模型。 ADMEMS方法强调“关键需求决定架构”的策略，“基于关键功能，进行初步设计”就是一个具体体现。 系统的每个功能都是由一条“职责协作链”来完成的；而初步设计的具体思路正是“通过为功能规划职责协作链来发现职责”。 "},"ch8/8.2.html":{"url":"ch8/8.2.html","title":"8.2. 鲁棒图简介","keywords":"","body":"8.2. 鲁棒图简介 ADMEMS推荐以鲁棒图来辅助初步设计。那么，什么是鲁棒图呢？ 8.2.1. 鲁棒图的3种元素 鲁棒图包含3中元素，它们分别是边界对象、控制对象、实体对象。 边界对象对模拟外包环境和未来系统之间的交互进行建模。边界对象负责接收外部输入，处理内部内容的解释，并表达或传递相应的结果。 控制对象对行为进行封装，描述用例中事件流的 控制行为。 实体对象对新鲜进行描述，它往往来自领域概念，和领域模型中的对象有良好的对应关系。 因为“类比思维”在人的头脑中是根深蒂固的，关于鲁棒图3元素的“类比”，自然是MVC。我们做了全面的对比，两者之间还是有不小的差异的。 鲁棒3元素和MVC的主要不同在于： View仅涵盖了“用户界面”元素的抽象，而鲁棒图的边界对象全面涵盖了三种交互，即本系统和外部“人”的交互、本系统与外部“系统”的交互、本系统与外部“设备”的交互。 数据访问逻辑Controller吗？不是。控制对象广泛涵盖了应用逻辑、业务逻辑、数据访问逻辑的抽象，而MVC的Controller主要对应于应用逻辑。 MVC的Model对应于经典的业务逻辑部分，而鲁棒图的实体对象更像“数据”的代名词--用实体对象建模的数据既可以是持久化的，也可以仅存在内存中，并不像有的实践者理解的那样直接就等同于持久化对象。 8.2.2. 鲁棒性一例 如银行存储系统的“销户”功能的鲁棒图。 为了实现销户的功能，银行工作人员要访问3个边界对象： 活期账号销户界面 磁卡读取设备 打印设备 “销户”是一个“控制对象”，和“计算利息”一起进行销户功能的逻辑控制。 其中，“计算利息”对“活期账户”、“利息率”、“利息税率”这3个“实体对象”进行读取操作。 而“销户”负责读出“客户资料”......最终销户的完成意味着写入“活期账号”和“销户流式”信息。 8.2.3. 历史 鲁棒图(Robustness Diagram)是由Ivar Jacobson于1991年发明的，用以回答“每个用例都需要哪些对象”的问题。 后来的UML并没有将鲁棒图列入到UML标准，而是作为UML版型（stereotype）进行支撑。 对于RUP、ICONIX等过程，鲁棒图都是重要的支撑技术。当然，这些过程反过来也促进了鲁棒图技术的传播。 8.2.4. 为什么叫“鲁棒”图 那为什么叫鲁棒图？它和鲁棒性有什么关系？ 答案是：词汇相同，含义不同。 软件系统的”鲁棒性（Robustness）“也是经常被翻译成”健壮性“，它同时和”容错性(Fault Tolerance)“含义相同。具体而言，鲁棒性指当下发生时依然具有正确运行功能的能力：非法输入数据、软硬件单元出现故障、未料到的操作情况。 鲁棒图的作用有两点： 初步设计 检查用例规约是否正确和完善 ”鲁棒图“正是因为第2点作用而得名的--所以，严格来讲”鲁棒图(Robustness Digagram)“所指的不是\"鲁棒性(Robustness)\"。 从Doug Rosenberg在《用例驱动的UML对象建模应用》的描述中，也可得到上述结论： 在ICONIX过程中，鲁棒分析扮演了多个必不可少的角色。通过鲁棒分析，您将改进用例文本和静态模型。 有助于区别用例文本的正确性，且没有指定不合理或不可能的系统行为（基于要使用的一组对象），从而提供了健康性检查（Sanity Check）。这种改进使用用例文本的特性从纯粹的用户手册角度变成对象模型上下文中的使用描述。 有助于区别用例考虑到所有必须的分支流程，从而提供了完整的正确性检查。经验表明，为实现这种目标，并编写出遵循某些定义良好的指南的问题，而在绘制鲁棒图上花费的时间，将在绘制时序图时3-4倍的节省下来。 有利于发现对象，这一点很重要，因为在建模期间肯定会遗漏一些对象。你还可以发现对象命名冲突的情况，从而避免进一步造成严重的问题。另外，鲁棒分析有利于确保我们在绘制时序图之前确定大部分实体类和边界类。 8.2.5. 定位 不要再困惑于类似”鲁棒图是分析技术，还是设计技术“这样的问题了。大家只需要记住两个公式： 需求分析 ≠ 系统分析 系统分析 ≈ 初步分析 关于”分析“和”设计“的区分，在《面向对象的系统设计》一书中早已做过精彩的阐述： 在”做什么“和”怎么做“来区分分析与设计，是从结构化方法沿袭过来的一种观点，但即使在结构化方法沿袭过来的一种观点，但即使在结构化方法中这种说法也很勉强...... 在”做什么“和”怎么做“为什么会出现上述矛盾？究其根源，在于人们对软件工程中”分析“这个术语的含义有着不同的理解--有时把它作为需求分析（Requirements Analysis）的简称，有时又指系统分析（Systems Analysis），有时则作为需求分析和系统分析的总称。 需求分析时软件工程学中的经典术语之一，名副其实的含义应是对用户需求进行分析，旨在产生一份明确、规范的需求定义。从这个意义上讲，”分析是解决做什么而不是解决怎么做“是无可挑剔的。 但迄今为止，在人们提出的各种分析方法（包括结构化分析和面向对象分析）中，真正属于需求分析的内容所占的分量并不大；更多的内容是给出一种系统建模方法（包括一种表示法和相应的建模过程指导），告诉分析员如何建立一个能够满足（由需求定义所描述的）用户需求的系统模型。分析员大量的工作是对系统的应用领域模型进行调查研究，并抽象表示这个系统。确切的讲，这些工作应该叫做系统分析，而不是需求分析。它既是对“做什么”问题的进一步明确，也在相当程度上设计“怎么做”的问题。 忽略分析、需求分析和系统分析这些术语的不同含义，并在讨论中将它们随意替换，是造成上述矛盾的根源。 至于实践者为什么常将“需求分析”和“系统分析”混淆，这背后有着重要的现实原因。实际的工程化实践中，需求捕获、需求分析、系统分析并不是完全孤立进行的。想法，它们往往是相互伴随、交叉进行的。需求工作伊始，无疑更多是进行需求捕获工作，相伴进行的需求分析工作所占的比例偏少；但随着掌握的需求信息越来越多，我们需要开展对需求的分析和整理工作也越来越多了；而此时，伴随着对问题的分析，自然而然会在高层次提出相应的应对策略......这恰恰就是系统分析工作。 《软件架构设计》一书中有如下阐述： 需求捕获是获取知识的过程，知识从无到有，葱烧到多。需求采集者必须立即用户所充实的工作，并了解用户客户希望软件系统在哪个方面能够帮助他们。 需求分析是挖掘和整理知识的过程，它在已掌握知识的基础上进行。毕竟，初步捕获到的需求信息往往处于不同的层次，也有一些主观深圳不正确的信息。而经过必要的需求分析工作之后，需求更加系统、更加有条理、更加全面。 那么系统分析呢？如果说，需求分析致力于搞清楚软件系统要“做什么”的话，那么系统分析已经开始涉及“怎么做”的问题了。 《系统分析与设计方法》一书中写道： 简单的说，系统分析的意义如下：“系统分析是针对系统所要面临的问题，搜集相关的资料，以了解产生问题的原因所在，进而提出解决问题的方法和可行的逻辑方案，以满足系统的需求，实现预定的目标。” 需求捕获、需求分析，以及系统分析之间的关系，我们必须理解透彻，否则会影响工作的有效进行。 再次强调，鲁棒图已经“打开”了“系统”这个“黑盒子”，将它划分成很多的不同的职责，所以它是“设计技术”。 "},"ch8/8.3.html":{"url":"ch8/8.3.html","title":"8.3. 基于鲁棒图进行初步设计的10条经验","keywords":"","body":"8.3. 基于鲁棒图进行初步设计的10条经验 ADMEMS方法归纳了鲁棒图建模的10条经验要点，分别覆盖了语法、思维、技巧、注意事项等4个方面。 语法 遵循建模规则 简化建模语言 思维 遵循3种元素的发现思路 增量建模 实体对象 ≠ 持久化对象 技巧 只对关键功能（用例）画鲁棒图 每个鲁棒图有2~5个控制对象 注意 勿关注细节 勿过分关注UI，除非辅助或验证UI设计 鲁棒图 ≠ 用例规约的可视化 8.3.1. 遵循建模规则 Doug Rosenberg在《UML用例驱动对象建模》中写道： 通过以下4条语言，可以理解该图的本质： 参与者只能与边界对象交谈。 边界对象只能与控制对象和参与者交谈。 实体对象也只能与控制对象交谈。 控制对象既能与边界对象交谈，也能与控制对象交谈，但不能与参与者交谈。 8.3.2. 简化建模语法 在实践中，简化的鲁棒图语法将有利于你集中精力进行初步设计，而不是关注细节。 例如，鲁棒图根本不关心“IF语言”怎么建模。 值得注意的是，业界有些观点（包括一些书）认为鲁棒图是协作图。因此造成了鲁棒图的语法非常复杂，不利于专注于初步设计。 其实，鲁棒图是一种非常特殊的类图。 8.3.3. 遵循3种元素的发现思路 用例（Use Case） = N个场景（Scenario）。每个场景的实现都是一连串的职责进行协作的结果。所以，初步设计可以通过“研究用例执行的不同场景，发现场景背后应该有哪些不同的职责”来完成。 8.3.4. 增量建模 “建模难”，有些人常如此感叹。例如，在画鲁棒图时，许多人以上来就卡在了“搞不清应该有几个界面”的问题上，就会发出“建模难”的感叹。 下面演示“增量建模”这种技巧。从小处讲，增量建模能解决鲁棒图建模卡壳的问题；从大处将，这种方式适合所有种类的UML图建模实践。 例如，类似WinZip、WinRar这样的压缩工具大家都用过。请一起来为其中的“压缩”功能进行基于鲁棒图的初步设计。 首先，识别最明显的职责。对就是你自己认为最显著的几个职责--不要任务设计和建模有严格的标准答案。 源文件 压缩包 压缩器（负责压缩处理） 接下来，开始考虑职责间的关系，并发现新职责。压缩器读取源文件，最终生成压缩包。 这里将打包器独立出来，它是受了压缩器的委托而工作的。还有字典...... 继续同样的思维方式，又引入了压缩配置，它影响着压缩器的工作方式，例如加密压缩、分卷压缩或其他。 压缩功能还要显示压缩进度，以及随时取消进行一半的压缩工作。所以，你又识别出了压缩进行界面和监听器等职责。 模型之于人，就像马匹之于人一样--它是工具。如果你不知道怎样真正将“模型”为自己所用，反而为“建模”所累（经典的“人骑马、马骑人”的问题），请问自己一个问题： 我是不是被太多的假设限制了思维？，或许，工具本身根本没有这样的限制我！ 8.3.5. 实体对象 ≠ 持久化对象 实体对象涵盖的更广泛，它可以是持久化对象，也可以是内存中的任何对象。 一方面，在实践中，有些系统需要在内存中创建数据的“暂存体”以保持中间状态，当然可以被建模成实体对象。另一方面，有的系统没有持久化数据，但是基于鲁棒图的设计依然可以用，此时难道鲁棒图不包含实体对象吗？显然不对。 因此，实体对象 ≠ 持久化对象，这个正确认识将有助于你的实践。 8.3.6. 只对关键功能（用例）画鲁棒图 基于“关键需求决定架构”的历练，功能需求作为需求的一种类型，在架构设计时不必针对每个功能都画出鲁棒图。 8.3.7. 每个鲁棒图有2~5个控制对象 既然是初步设计，鲁棒图建模时，针对关键功能的每个鲁棒图中的控制对象不必太多太细，5个是常见的上限值。 相反，若实现某个功能的鲁棒图只包含一个控制对象，则是明显的“设计不足”--这个控制对象的名字必然和功能的名词相同，这意味着没有对职责进行真正的切分。 例如，WinZip的压缩功能设计成下面的鲁棒图，几乎没有任何意义。 8.3.8. 勿关注细节 初步设计不应该关注细节。例如，回顾前面所示的“销户”的鲁棒图： 对每个对象只标识对象名，都未识别其属性和方法。 “活期账户销户界面”，具体可能是对话框、Web页面、字符终端界面，但鲁棒图中没有关心这些细节问题。 “客户资料”等实体对象必须要持久化吗？不关心，更不关心用Table还是File或其他方式持久化。 没有标识控制流的严格顺序。 8.3.9. 勿过分关注UI，除非辅助或验证UI设计 过分关系UI，会陷入诸如有几个窗口，是不是有一个专门的结果显示页面等诸多细节之中，初步设计就没法做了。 别忘了，初步设计的目标是发现职责。初步设计无需展开架构设计细节，否则就背上了“包袱”，这是复杂系统设计起步时的大忌。 8.3.10. 鲁棒图 ≠ 用例规约的可视化 鲁棒图时设计，“系统”已经别切分成不同的职责单元。而用例规约是需求，其中出现的“系统”必定是黑河。所以，两者有本质区别。 "},"ch8/8.4.html":{"url":"ch8/8.4.html","title":"8.4. 贯穿案例","keywords":"","body":"8.4. 贯穿案例 接下来考虑贯穿案例PASS系统，如何借助鲁棒图进行初步设计呢？ 再次明确一下几点： 初步设计的目标是发现职责，为高层切分奠定基础 初步设计不是必须，但待设计的系统对架构师而言并无太多直接经验时，强烈建议进行初步设计 基于关键功能（而不是所有功能），借助鲁棒图（而不是时序图）进行初步设计 下面，我们一起思考如何针对“实时检查处方”功能进行初步设计--重点体会“增量建模”的自然和强大。 首先，识别最明显的职责。先识别出最不可或缺的、体现整个功能价值所在的、与“处方检查结果”相关的几个职责。 接下来开始考虑职责间的关系，并发现新职责。检查结果是如何产生的呢？检查这个控制对象，读取处方和用户规则信息，最终生成处方检查结果。 OK，如此一来，解决了“结果是怎么来的这个问题”。 继续以同样的思维方式解决问题。PASS系统自动检查处方，是由HIS系统中意识工作站的调用触发的，处方信息也是通过某种方式（例如参数或XML文件）从HIS医生工作站获得的。 实时检查处方最终的鲁棒图又进一步考虑了“记录违规用药”这一具体功能场景的支持。 概念架构设计时推荐只对关键功能进行鲁棒图建模。例如，另一关键功能“自动更新用药规则”的鲁棒图设计如下： "},"ch9/":{"url":"ch9/","title":"第9章 高层分割","keywords":"","body":"第9章 高层分割 复杂性是层次化的。 -- Frederick.P.Brooks,《人月神话》 分析与综合是思维方向相反的过程。一部是先分析后综合，没有分析就不能综合；没有综合的分析，也只有片面的分析。 -- 肖纪美，《梳理人、事、物的纠纷：问题分析方法》 “架构 = 模块 + 接口”的做法，其不足可概括为两点。 第一，忽视了多视图。“模块 + 接口”仅是逻辑架构设计视图的核心内容，而软件系统的架构设计还可能涉及开发视图、运行视图、物理视图、数据视图等多方面的考虑。 第二，忽略了概念架构设计。对规模较大的系统而言，都必须先根据重大风险（包含功能方面、质量方面、约束方面），有针对性的制定包括“高层分割”在内的设计决策，然后才是“模块 + 接口”一级的设计。 那么，如何对软件系统进行“高层分割”呢？这属于Conceptual Architecture阶段第2步的工作。也真是这一章要说的主题。 "},"ch9/9.1.html":{"url":"ch9/9.1.html","title":"9.1. 高层分割的两种实践套路","keywords":"","body":"9.1. 高层分割的两种实践套路 切系统为系统 切系统为子系统 在实践中，经常出现这两种方式。虽然从理论上，设计是层层嵌套展开的--即“每一级的子系统”对“下一级的子系统”而言都是系统，都可以单独定义需求和进行设计。但这里更强调“两种套路”的思维。 也就是说： 要么告诉自己：我面对的是1个“系统的系统(System of Systems)” 要么告诉自己：我要把这个“原子系统”切成若干子系统 9.1.1. 切系统为系统 “切系统为系统”是一种缩略的说法，具体是指： 系统比较复杂，需要进行两级高层切分。 首先，把系统切成更小一级的系统，每个更小一级都可以有单独的需求、设计、实现...... 之后，针对每个“更小一级的系统”进行“切系统为子系统”...... 这样做的现实意义是巨大的。 面临比较复杂的软件系统，很多企业都有“这个项目要设几个架构师”的困惑。以电信或广电领域的BOSS系统为背景。 在实践中，当面临如下两种情况时，你需要考虑“切系统为系统”： 当系统覆盖的功能范围比较广泛 例如，BOSS系统设计的需求范围广泛--涵盖网络管理、服务开通、计费、客户关系管理等，于是按照“切系统为系统”的做法分为网管系统、服务受理系统、计费系统、客户关系管理系统等。 当系统需要部署在比较复杂的硬件环境中 很多城市基础服务行业、大型机构、大型企业，都很重视“一卡通”的应用。例如，如一卡通系统要无缝支持HR管理、出入控制、后勤保障等方面的功能，就必须充分考虑复杂的硬件环境给架构带来的冲击--硬件的种类设计考勤机、通道机、闸机、自助查询机、PC机、服务器等，于是应当合理规划组成整个一卡通系统的嵌入式应用、桌面应用及Web应用等。 9.1.2. 案例：SAAS模式的软件租用平台架构设计 再举一例，来说明如何进行“切系统为系统”式的高层分割。 案例背景 SAAS风潮又起（以前叫ASP），“软件租用平台”为用户提供统一的软件租用服务。如上下文图 软件租用平台提供的高层功能描述，如业务用例图。 高层分割的思维 业界有数据表明，需求的复杂程度没增加25%，解决方案的复杂程度就增加100%。那么，我如果应该把“软件租用平台”切成三四个相对独立的系统而没切，就意味着人为的制造灾难--太多问题相互杂糅在一起，造成解决方案的复杂程度陡增。 借助鲁棒图，初步识别功能背后的职责，就可以规划高层切分的具体方式。 具体思维过程如下： 结果呢？1个系统被切为3个系统--组件管理系统、运营管理系统、应用定制系统。 分别设计和开发这3个单独的系统，比直接把软件租用平台当成1个System开发的可控性高多了。复杂性是根本问题（《人月神话》语），虽然无法降低，但是可以控制。 9.1.3. 切系统为子系统 这种方式相当经典，无需太多铺垫。实践中，最常见的就是分层。 案例背景 使用用例图来描述PM系统的功能 高层分割 PM系统的高层分割，采用了经典的4层架构方式。 "},"ch9/9.2.html":{"url":"ch9/9.2.html","title":"9.2. 分层式概念服务架构","keywords":"","body":"9.2. 分层式概念服务架构 人们常说，“分层式最流行的架构模式”。从字面上理解，这似乎意味着大家所进行的“分层”在思想层面上是一致的。但事实并非如此。在实践中，分层有不同的角度，并且互不矛盾。通常会总结为“3 + 1”流派。 Layer：逻辑层 Tier：物理层 按通用性分层 技术堆叠 9.2.1. Layer:逻辑层 逻辑层(Layer)重视职责的划分，职责之间常常是上层使用下层的关系--但是根本不关心上层和下层是否“能分布”在不同机器上。 图片来源：Layered Business Architectures: Logical Structures 图中的Services层对下层Domain Model部分的访问，是一种跨机器的远程访问吗？ 答案是：不知道，也不关心。整个架构图中的箭头表示的是逻辑上服务使用关系，而对物理角度是否是跨机器的访问方式并不关心。 按Layer分层 ≠ 按Tier分层。 图中的User Interface、Services、Domain Model和Persistent Data是通用性逐渐增加吗？（”通用性越大，所处层次就越靠下“是按通用性分层的常见方式。） 答案是：无法确定那一层更通用。例如，作为最下层的Persistent Data层本来支持硬盘，但后来要支持磁盘阵列，再后来要支持SAN（存储区域网络），这都要求存Persistent Data层要有针对性的进行改变。 按Layer分层 ≠ 按通用性分层。 9.2.2. Tier: 物理层 物理层(Tier)指”能分布“在不同机器上的软件单元，不同的物理层之间必须有跨机器访问的能力--可以通过远程调用、或通讯协议等方式。 图片来源：Oracle Application Server Containers for J2EE 关于Tier这种分层方式， 最需要强调的是，几层(Tier)架构是看”能分布“的能力，不是看”实际部署情况“。 我们常说的Java EE应该是N-Layer的，因为从逻辑上来看，Java EE里面有表现层、业务逻辑层和数据持久层。从物理上而言，这3层可以在不同的Tier上（表现层在PC上，业务逻辑层在应用服务器上，数据持久层在数据库服务器上），也可以在一个Tier上，比如Martin说过，如果把数据库、应用服务器和浏览器都装在一台电脑上，那么3-layer就在1-tier上了。 这段话问题不小。 毕竟，”N-Tiers架构“的一大好处是可伸缩性--业务量小的时候将N个Tier都部署在同一台机器上 ，等业务量大的时候再为每个Tier单独安排一台或一组机器，这恰恰是\"N-Tiers架构\"的目标！所以，一个系统如果架构设计时是”4-Tiers架构“的，并且开发时也实现了这一点，那么把它们部署在同一台机器上并没有改变”4-Tiers架构“。最终，工程师的实际部署方案觉得了系统是几层(Tier)架构，这未免荒唐。 其实，总结出”3级“映射关系（而不是”两级“）就清楚了： 逻辑层Layer -> 物理层Tier -> 一台或一组计算机 关于按Tier分层 ，再看一例：微软的Azure虚拟网络系统，很明确的进行了不同的tier的划分，各层之间必然是能以进行跨机器方式的协议互相通讯的（只不过每个Tier的部署规模比较大罢了）。 图片来源：Azure中具有Apache Cassandra的Linux多層式架構 (N-tier) 應用程式 9.2.3. 按通用性分层 严格来讲，按通用性分层是另一种Layer，但是，绝对有必要让它”独立门户“以引起实践者的足够重视。 按通用性分层式只：将通用性不同的部分划归不同的层，以此作为系统的总体切分方式。 一般而言，通用程度越大，所处层次就越靠下。 不同，嵌入式系统的分层架构有所不同：通用性最强的层位于中间，硬件相关的部分，以及应用特点部分分布位于下层和上层。 这种“中间通用、上下专用”的分层方式对可移植性关键的通信系统、控制系统、软件平台等情况都非常重要。 9.2.4. 技术堆叠 技术堆叠不是独立的架构，而是基于分层架构（或其他架构模式）提供的进一步说明。 下面这个两个架构模式都是按Tier分层，并明确了各个技术点。 图片来源：I Love the Java Jive: J2EE for Oracle Technologists 图片来源：Category Archives: Day 15. Understanding J2EE Architecture 另一个例子，基本架构模式是基于通用性分层的，也加入技术堆叠的描述。 图片来源：Java SpringMVC "},"ch9/9.3.html":{"url":"ch9/9.3.html","title":"9.3. 给架构师的提醒","keywords":"","body":"9.3. 给架构师的提醒 许多架构师认为，架构就是把系统切成框框，再在框框之间连上线。这种观点太片面了。 高层分割很重要，但不是概念架构的全部。除了切分策略之外，概念架构还包括技术选择、权衡策略等种类的决策。 例如，为了支持各种相互矛盾的非功能需求，仅调整切分方式还远远不够的。 "},"ch9/9.4.html":{"url":"ch9/9.4.html","title":"9.4. 贯穿案例","keywords":"","body":"9.4. 贯穿案例 继续PASS系统的贯穿案例。 由于PASS系统的分布式特点明显，所以高层分割除了考虑常见的Layer方式之外，我们也考虑Tier。而通过主动考虑“按通用性分层”，我们也大有收获--确定引入“PASS医生模块通用SDK”而使无谓的重复开发工作量降至最低。 9.4.1. 从初步设计到高层分割的过渡 我们在之前完成了初步设计成果，通过对这些已发现的职责进行“综合”，可以确定系统基本的高层分割方式。 9.4.2. PASS系统Layer设计 于是，可以得到按Layer对PASS系统进行高层分割的方式。 9.4.3. PASS系统之Tier设计 按Layer切分为反应PASS系统很强的分布式特点，我们应进一步从Tier角度考虑PASS系统的高层分割方式。 9.4.4. 引入通用性分层 如果进一步质疑“可重用性”(详见第10章的“贯穿案例”部分的目标-场景-决策表)，应将嵌入HIS的程序进一步切分--分出“PASS系统医生模块通用SDK”，它和任何具体HIS无关，所以通用性高，应分离出去。 "},"ch10/":{"url":"ch10/","title":"第10章 考虑非功能需求","keywords":"","body":"第10章 考虑非功能需求 架构不仅仅是系统功能需求的结果 -- Len Bass, 《软件架构实践(第二版)》 在我们当中，有不少人一厢情愿的认为：只要所开发出的系统完成了用户期待的功能，项目就算成功了，但这并不符合实际。 -- 温昱,《软件架构设计》 《软件架构设计》一书中指出，“其实任何作为复合整体的复杂事物都有可能有架构，比如一本书”。“非功能目标的考虑”在ADMEMS方法中不是一个阶段，而是一个贯穿环节。 我们接下来讨论的重点是贯穿案例 -- PASS系统概念架构设计的第3步，考虑非功能需求。 "},"ch10/10.1.html":{"url":"ch10/10.1.html","title":"10.1. 考虑非功能目标要趁早","keywords":"","body":"10.1. 考虑非功能目标要趁早 概念架构 ≠ 理想化架构 重大需求塑造概念架构。这里的 “重大需求”应涵盖功能需求、质量及约束3类需求中的关键部分。 概念架构是一个“架构设计阶段”，必须在细化架构设计阶段之前，针对重大需求、特色需求、高风险需求，形成稳定的高层架构设计成果。 如果只考虑“功能需求”来设计概念架构，将导致概念架构沦为“理想化架构”，这个脆弱的架构不久就会面临“大改”的压力，甚至直接导致投标等工作失败。 "},"ch10/10.2.html":{"url":"ch10/10.2.html","title":"10.2. 贯穿案例","keywords":"","body":"10.2. 贯穿案例 非功能需求往往非常笼统，而场景是一种明确性很强的技术。目标-场景-决策表可以让架构师理性应对非功能需求。 通过场景，我们质疑ile可重用性的做法。为了避免开发多个孤立的“医生工作站嵌入单元”，引入的设计决策是 “分离出不变部分”，将“PASS系统医生模块通用SDK”提炼出来（见9.4.4. 引入通用性分层） 不要忘记了架构设计是质疑驱动的--概念加过也经常经过多次循环的设计结果(如7.4. 实践要领提到概念架构实践要领)。现在我们来质疑PASS系统的持续可用性，它毕竟是用于辅助医院运营的系统。 根据上述基于目标-场景-决策表的思考，我们调整系统的原有架构图，经验告诉我们，考虑非功能需求会引起“架构中间设计成功”的调整！ "},"ch11/":{"url":"ch11/","title":"第11章. 细化架构的故事","keywords":"","body":"第11章. 细化架构的故事 如果一个项目的系统架构（包括理论基础）尚未定义，就不应该进行此系统的全面开发。 -- Barry Boehm, 《Software Engineering》 如果选择视图的工作没做好，或者以牺牲气体视图为代价，只注重一个视图，就会掩盖问题以及延误解决问题。 -- Grady Booch, 《UML用户指南》 从概念架构到细化架构，先设计概念架构，构思关键问题的解决策略；再进行细化架构的设计，以保证为开发提供足够的指导和限制...这符合人类解决问题的规律，因此被广泛采用。 但在实际中，细化架构设计还存在很多差强人意之处，甚至经常被忽视。 "},"ch11/11.1.html":{"url":"ch11/11.1.html","title":"11.1. 骄傲的架构师，郁闷的程序员","keywords":"","body":"11.1. 骄傲的架构师，郁闷的程序员 11.1.1. 故事：《方案书》确定之后 公司在谈一个项目，但还没有得到客户的认可。后来，除了老李这个项目经理之外，小张作为架构师、小王作为需求分析师也都参与了进来。他们几个在和客户沟通的基础上，通力合作，最后成功提交了《方案书》，并获得客户的认可。《方案书》是老李、小张、小王各负责一部分来写的，其中架构师小张负责总体设计部分。 小张认为：《方案书》被认可说明架构已经很明确，无须“再”架构设计了。 最后，苦了程序员，因为他们在实际开发过程中没有得到足够的指导和限制。 11.1.2. 探究：“方案”与“架构”的关系 究其原因，这是因为概念架构难以支持并行开发。要支持开发组相对独立进行工作，需要提供指导和限制作用更明确的“规约”一级的设计。 具体而言，细化架构和概念架构之间存在如下典型差异： 接口：在细化架构中接口占据非常核心的地位，而概念架构并不明确接口定义（只有抽象的组件和抽象的交互机制）。 子系统：细化架构重视通过子系统和模块来分割整个系统，并且子系统往往有明确的接口；而概念架构中只有抽象的组件，这些组件没有接口，只有职责，一般是处理组件、数据组件胡哦哦连接组件中的一种。当然，概念架构中也有“大组件分解成小组件”的设计决策，但并非子系统的含义。 交互机制：细化架构中的交互机制应是“实在”的，如基于接口编程、消息机制或远程方法调用等；而概念架构中的交互机制是“概念化”的。例如“A层使用B层的服务”就是典型的例子，这里的“使用”到了细化架构中可能基于接口编程、消息机制或远程方法调用等其中的一种。 当然，概念架构和细化架构都满足软件架构的定义--无论是“架构 = 组件 + 交互”，还是“架构 = 重要决策”。 方案的设定，为什么需要项目负责人、需求人员、架构师等功能参与呢？因为方案涉及的工作内容不仅仅是架构，还涉及项目管理和需求工作。“方案”和“架构”的联系与区别如下： 方案包含一定的架构内容 方案涉及的架构基本在概念架构一级 架构设计的工作还远未完成 所以，架构师应记住： 方案 = “项目 + 需求 + 架构”的总览 方案 ≠ 架构的全部 "},"ch11/11.2.html":{"url":"ch11/11.2.html","title":"11.2. 办公室里的争论","keywords":"","body":"11.2. 办公室里的争论 11.2.1. 故事：办公室里，争论正酣 办公室里，关于什么是软件架构，争论正酣。 程序员说，软件架构就要决定要编写哪些类，使用哪些现成框架(Framework)。 程序经理说，软件架构就是模块的划分和接口的定义。 系统分析员说，软件架构就是为业务领域对象的关键建模。 配置管理员说，软件架构就是开发出来的及编译后的软件到底是啥结构。 数据库工程师说，软件架构规定了持久化数据的结构，其他一切不过是对数据的操作而已。 部署工程师说，软件架构规定了软件部署到硬件的策略。 用户说，软件架构就是决定一个个功能子系统如何划分。 大家想了想说，这些架构视图好像我们都需要啊，软件架构师哭了。 11.2.2. 探究：优秀的多视图方法，应贴近实践 上述争论可以总结为一句话：不同涉众看待软件架构的视角是不同的。 但是，实际工作中架构师的工作范围如此广泛，多视图方法能系统的涵盖吗？例如： 进程、线程的相关设计 接口的定义 子系统的划分 服务器的选型 （若你用C）结构化方法的模块设计“放”哪里？ 考虑Layer（逻辑层） 考虑Tier（物理层） （基于并行开发的需要）源程序目录结构的定义 数据分布与数据库Schema (若没选RDBMS而选了文件方式)文件格式的定义 （嵌入式系统常将数据保存到Flash）Flash存储结构的定义 ...... 答案是：贴近实践的多视图方法，应将各项工作涵盖其中。 运行架构 进程、线程的相关设计 逻辑架构 接口的定义 子系统的划分 （若你用C）结构化方法的模块设计“放”哪里？ 考虑Layer（逻辑层） 物理架构 服务器的选型 考虑Tier（物理层） 开发架构 （基于并行开发的需要）源程序目录结构的定义 数据架构 数据分布与数据库Schema (若没选RDBMS而选了文件方式)文件格式的定义 （嵌入式系统常将数据保存到Flash）Flash存储结构的定义 "},"ch11/11.3.html":{"url":"ch11/11.3.html","title":"11.3. 展望细化架构阶段","keywords":"","body":"11.3. 展望细化架构阶段 总结一下。首先，架构设计仅进行到概念架构层面，对团队的并行开发而言是远远不够的；常见的错误就是把《方案书》中的概念架构设计部分直接作为《架构设计文档》提交。另外，业界早已存在一些有影响力的多视图方法（例如RUP4+1视图方法），但是作为一线架构师，要有意识的调整、扩充、改进经典方法以符合实践的真正需要。 "},"ch12/":{"url":"ch12/","title":"第12章. 细化架构总论","keywords":"","body":"第12章. 细化架构总论 假设有一座漂亮的大房子，一个人站在房子的前面，一个人站在房子的后面，另外两个人分别站在房子的左右两侧。四个人看房子都有不同的视角，四个人都在争论自己看到的那一面是正确的一面，如果运用水平思考，那么这四个人就会绕房子一圈，分别看到房子前后左右四个面。 -- 爱德华.德.博诺，《六顶思考帽》 总的来说，“架构”一词涵盖了软件架构的所有方面，这些方面紧紧的缠绕在一起，决定如何将之分割成部分和主题显得相当主观。既然如此，就必须引入“架构视点”作为讨论、归纳和理解大型系统架构的手段 -- Peter Herzum, 《Business Component Factory》 架构设计是一门解决复杂问题的实践艺术。于是，以分而治之为思想核心的多视图方法必不可少。 接下来主要介绍支持细化架构设计的整体思路--多视图方法。 "},"ch12/12.1.html":{"url":"ch12/12.1.html","title":"12.1. 什么是细化架构","keywords":"","body":"12.1. 什么是细化架构 细化架构是相对于概念架构而言的，它们是架构设计的两个层次，分别对应于“概念级”解决方案和“规约级”解决方案。需要注意的是，系统架构属于架构设计，不能和Detailed Design(详细设计)相混淆。 架构领域最喜欢将建筑设计的多视图方法与软件架构设计的多视图方法做类比，在此就不在进行赘述，而是举一个更贴近生活的例子：装修的多视图方法 功能视图 布线视图 通过运用装修的两视图法，你的装修设计摆脱在一个图里画来画去（想来想去）的困境。其中，装修设计的功能视图比较多的考虑： 家具 家电 灯 窗帘 而布线视图则集中考虑： 插座 网线 电话线 有线电视线 我们还发现，功能视图和布线视图是相互影响的，例如插座不能设计在大衣柜的后面，否则无法使用。这与软件架构设计的多视图方法中“兼顾多个视图设计之间的一致性”的要求是神似的，例如架构设计要考虑职责、程序单元、部署节点等要素之间的相互影响。 "},"ch12/12.2.html":{"url":"ch12/12.2.html","title":"12.2. 实际意义","keywords":"","body":"12.2. 实际意义 关于多视图方法的价值，Len Bass等专家在《软件架构实践（第2版）》一书中论述道： 神经科专科医生、整形医生、血液专家和皮肤科医生对人体结构有着不同的视图。眼科医生、心脏病专家和足病医生研究治疗的是身体的某个部分。运动学专家和精神病专家关注的是整个人体行为的不同方面。尽管这些视图是不同的并且具有差异巨大的属性，但它们都具有内在相关性：它们共同描述了人体的结构。 软件也是如此。现代系统非常复杂，很难一下领会。相反，在任何时刻，我们只能把注意力放在软件系统的一个或几个结构上。为了有意义的传达架构的信息，必须说明此刻正在讨论哪个或哪些结构--即采用的是架构的哪个视图。 所以，多视图方法有两个方面的实际意义： 利于思考（因为分而治之的思维方式） 便于交流（因为在一定程度上分类了涉众关注点） "},"ch12/12.3.html":{"url":"ch12/12.3.html","title":"12.3. 业界现状","keywords":"","body":"12.3. 业界现状 12.3.1. 误认为多视图是OO方法分支 提问：Framework技术是OO的分支吗？不是，Framework本质上和面向对象无关，用C语言也可以编写Framework。更切切近本质的Framework的定义是：可以通过某种回调机制进行扩展的软件系统或子系统的半成品。 的确，OO方法太流行了，以至于很多技术都“变成”了OO的分支。 有同行也常常将多视图方法误认为是OO方法的分支。其实，无论是OO方法，还是结构化方法，都远未涵盖架构设计的全部。所以，只具有OO技能对架构师而言是不够的。 12.3.2. 误将“视图”当成“阶段” 对架构设计方法而言，区分阶段和视图的概念是非常重要和必要的。 “左边”的观点--概念架构、逻辑架构、物理架构是3个不同的层次。其实这种观点不完全正确，因为逻辑架构和物理架构是架构设计同一阶段中须要同时考虑的两个方面--即二者是两个视图，而非两个阶段。 12.3.3. RUP 4+1视图 在软件架构发展史上，4+1视图方法具有重大贡献。 1995年，Philippe Kruchten发表了题为《The4+1 View Model of Architecture》的论文，标志着4+1视图方法的诞生。后来，Philippe Kruchten加入Rational公司，4+1视图演化为下图所示的模样。 RUP4+1视图方法有几个重要特点： 重视OO方法 Use Case驱动 强调模型的重要性 对应于上述3个特点，架构师在实践中应注意： OO可以指导逻辑架构视图的设计，但是OO方法对物理视图等的设计指导很弱。另一方面，即使逻辑架构的设计，也未必都是以OO方法为指导的。例如，大量嵌入式软件系统和系统软件仍以C语言为主要开发语言，其逻辑架构设计还会以结构化方法为指导。 用例不是架构设计本身工作。4+1视图中的“4”是架构设计，“+1”是驱动因素。 建模切忌穷兵黩武。如果一个模型建立中没有启发思维，首次建立后从不修改，那么就要慎重考虑是不是“过度建模”了。 12.3.4. SEI 3视图 SEI的Len Bass等专家在《软件架构实践（第2版）》中阐述了“3视图”的观点，他们认为架构设计的工作应该包含3类视图： 模块视图：此处的元素是模块，它们是实现单元。模块表示一种考虑系统的基于代码的方法。模块被分配功能职责区域。这不怎么强调所开发出来的软件如何在运行时表现自己。模块结构能够回答诸如此类的问题：分配给每个模块的主要功能职责是什么？允许模块使用的其他元素是什么？它实际使用的其他软件是什么？什么模块通弄个泛化或特化（继承）关系与其他模块相关？ 组件-连接器视图：此处的元素为运行时组件（它们是计算的主要单元）和连接器（它们是组件间通信的工具）。组件-连接器结构回答了诸如此类的问题：we和你们是主要执行组件？它们如何交互？什么是主要的共享数据存储？复制系统的那些不法？数据在系统中经过了哪些地方？系统的哪些部分可以并行运行？在系统执行时，其结构可能会发生怎样的变化？ 分配视图：分配结构展示了软件元素和创建并执行软件的一个或多个外部环境中的元素之间的关系。它们回答了诸如此类的问题：每个软件元素在什么处理器上执行？在开发、测试和系统构建期间，每个元素都存储在什么文件中？分配给开发小组的软件元素是什么？ 来源：《Software Architecture in Practice》 总的来说，SEI 3视图方法没有RUP 4+1视图方法影响大，但也值得架构师研究和体会的。 例如： 映射视图对实践很有启发。以源码为核心的开发单元要分配给开发人员；而目标单元要和吴磊节点有映射关系，通过安装、部署、烧写等时候藕断完成。 “架构 = 组件 + 交互”是业界的基本认识，应该在架构的每个视图都有自己关心的“组件”。 "},"ch12/12.4.html":{"url":"ch12/12.4.html","title":"12.4. 实践要领","keywords":"","body":"12.4. 实践要领 一种优秀的多视图方法，应该能够比较完善的覆盖架构设计的各项哦工作内容，且将每项工作内容明确的、有理有据的、一目了然的规划到不同架构视图中去。 我们来介绍一下5视图方法的怨气，并用两幅画来说明5视图方法的主要思想：落错有致的将众多技术关键点划分成“群落”，“群落”高内聚，“群落”之间松耦合。所以，应用5视图方法，有利于架构师设计思维的“有序”展开。 12.4.1. 缘起：5视图方法的提出 多视图方法是业界广泛认同的一种架构设计思路，具体的多视图方法繁多： SEI的3视图方法。涉及视图为：模块视图、组件-连接器视图、分配视图。 西门子的4视图方法。涉及视图为：概念视图、模块视图、代码视图、执行视图。 RUP的4+1视图法。涉及视图为：用例视图、逻辑视图、开发视图、进程视图、物理视图。 联邦企业架构框架（Federal Enterpriese Architecture Framework）。涉及视图为：技术架构视图、信息架构视图、应用架构视图、业务架构视图。 其他...... 其中，无疑是由Philippe Kruchten于1995年首次提出的4+1视图方法的影响最大。 12.4.2. 总图：每个视图，一个思维角度 《第一财经》栏目有句广告语“有角度就有空间”，想想都觉得颇有道理--作为电视节目，选准了评论的“角度”，也就有了建立观点的“空间”。 而多视图方法背后的核心思想就与此有些类似： 从不同角度，规划“分割”与“交互”。 5视图方法包含如下几个视图： 逻辑视图 开发视图 运行视图 物理视图 数据视图 5个视图各有其“思维立足点”，分别是： 职责划分（逻辑视图） 程序单元组织（开发视图） 控制流组织（运行视图） 物理节点安排（物理视图） 持久化设计（数据视图） “思考最大的障碍在于混乱”。抓住每个视图的“思维立足点”。5视图方法就显得“相当清楚”了。 12.4.3. 详图：每个视图，一组技术关键点 接下来，看看架构师最关注的众多技术关注点，如何被5视图梳理的清楚。 例如，Layer是一种大粒度的“职责划分”单位，Layer的定义属于逻辑架构视图；而Tier则属于物理架构视图的考虑范围，它关注与硬件部署。 再例如，对于嵌入式系统而言，有经验的架构师能够从上图中“发现”自己的习惯做法： 控制流不仅仅包含进程和线程，中断服务程序也是一种重要的控制流机器（运行架构视图） 嵌入式应用数据的持久化常常基于文件（而不是数据库）的概念，最终常写入Flash（而不是硬盘）中（数据架构视图） ...... 如果说每个视图都是一个“语言”的话，那么视图内的那些技术关注点就是语言的“词汇”，正是这些不同的技术关注点支撑起不同的思维空间。 最后，看似复杂的5视图方法其实很简单，因为其每个视图都是从特定角度规划系统的分割与交互，都是（架构的定义）“组件 + 交互”的一种体现。--原来如此，提炼出了“繁”中之“简”，离成功运用这种方法就不远了！ "},"ch13/":{"url":"ch13/","title":"第13章. 逻辑架构","keywords":"","body":"第13章. 逻辑架构 有没有一种方法在大产品和小团队之间的缺口上架起一座桥梁呢？答案是肯定的，有！那就是架构。架构最重要的一点，就是它能把难以处理的大问题分解成便于管理的小问题。 -- Eric Brechner，《代码之道》 一流是每个程序设计人员向往并为之奋斗却又无法具体说出的、难以达到的境界，一流的软件非常简明。它灵活而清晰，能通过创造性的机制解决复杂的问题，这些机制语义丰富，可应用于其他可能完全无关的问题，一流意味着寻求恰当的抽象，意味着通过新的途径合理利用有限的资源。 -- Grady Booch，《面向对象项目的解决方案》 划分子系统、定义接口......，这些典型工作都是属于逻辑架构设计的范畴。 接下来，我们主要说说5视图方法中逻辑架构视图的设计： 先从划分子系统的3种必用手段讲起 随后，纠正“我的接口我做主”这种错误认识，代之以“协作决定接口”的正确理解 而且，接下来将解析逻辑架构设计的整体思维套路，解决架构师郁闷已久的“多视图方法只讲做什么、不讲怎么做”的问题 最后，总结逻辑架构设计的10条经验要点。 "},"ch13/13.1.html":{"url":"ch13/13.1.html","title":"13.1. 划分子系统的3种必用策略","keywords":"","body":"13.1. 划分子系统的3种必用策略 架构师最缺的不是理论，也不是技术，而是位于理论和技术之间的“实践策略”和“实践套路”。 就划分子系统这个架构师必须做的工作而言，其实实践策略可以归纳为3种： 分层的细化 分区的引入 机制的提取 13.1.1. 分层(Layer)的细化 分层是最常用的架构模式：在架构设计初期，100%的系统都可以用分层架构，就算随着设计的深入而采用了其他架构模式也未必和分层架构矛盾。 于是，架构师在划分子系统时常受到初期分层方式的影响--实际上，很多架构师最熟悉、最自然的划分子系统的方式就是：分层的细化。 3层架构或4层架构的“倩影”经常出现在投标时，或者市场彩页中，于是有人戏称之为“市场架构”。的确，直接用3层架构或4层架构来支持团队的并行开发是远远不够的。所以，“分层的细化”是划分子系统的必用策略之一，架构师们不要忘记。 13.1.2. 分区(Partition)的引入 序幕才刚刚拉开，划分子系统的工作还远远没有结束。 迭代式开发挺盛行，但所有真正意义上的迭代开发，都必须解决这样一个“困扰”：如果架构设计中只有“层”的概念，以“深度优先”的方式完成一个个具体功能就不可能的！ 所以，工程师们就经常遇到这样的烦恼 例如《代码之道》一书中就论及了这一点： 为了得到客户经常性的反馈，快速迭代有个基本前提：开发应该是“深度优先”，而不是“广度优先”。 广度优先极端情况下意味着每一个功能进行定义，然后对每个功能进行设计，接着对每个功能进行编码，最后才能对所有功能一起测试。而深度优先极端情况下意味着每个功能完整的进行定义、设计、编码和测试，而只有当这个功能完成之后，你才能做下一个功能。当然，两个极端都是不好的，但深度优先要好的多。对于大部分团队来说，应该做一个高级广度设计，然后马上转到深度优先的底层设计和实现上去。 为了支持迭代开发，逻辑架构设计中必须（注意是必须）引入分区。分区是一种单元，它位于某个层的内部，其粒度比层 要小。一旦架构师针对每个层进行了分区设计，“深度优先”式的迭代开发就非常自然。 ，支持迭代开发.png) 架构是迭代开发的基础。架构师若要在“支持迭代”方面不辱使命，必须注重“分区的引入”--这也是划分子系统的必用策略之一。 13.1.3. 机制的提取 Grady Booch在他的著作中指出： 机制才是设计的灵魂所在......否则我们就不得不面对一群无法相互协作的对象，它们相互推搡着做自己的事情而不关心其他对象。 机制之于设计是如此的重要。那么，什么是机制呢？ 那“机制”的定义是：软件系统中的机制，是指预先定义好的、能够完成预期目标的、基于抽象角色的协作方式。机制不仅仅包含协作关系，同时也包含了协作流程。 对于面向对象方法而言，“协作”可以定义为“多个对象为完成某种目标而进行的交互”，而“协作”和“机制”的区别可以概况为： 基于接口（和抽象类）的协作是机制，基于具体类的协作则算不上机制。 对于编程实现而言，在没有提取机制的情况下，机制是一种隐式的重复代码--虽然语句直接比较并不相同，但是很多语句只是引用的变量不同，更重要的是大段的语句块结构完全相同。如果提取了机制，它在编程层面体现为“基于抽象角色（OO中就是接口）编程的那部分程序”。 对于逻辑架构设计而言，机制是一种特殊的子系统--架构师在划分子系统时不要忘记这一点。最容易理解的子系统，是通过“直接组装”粒度更小的单元来是吸纳软件的”最终功能“。在实现不同的最终功能时，可以重用同一个机制，避免重复进行繁琐的”组装“工作。例如，网络管理软件中拓扑显示和告警通知都可利用消息机制。 13.1.4. 总结：回顾”三维思维“ 至此，我们讨论了划分子系统的3种手段：分层的细化、分区的引入、机制的提取。通过这3种手段的综合运用，就可更理性、更专业的展开逻辑架构的设计。 如何通过关注点分离来达到“系统中的一部分发生了改变，不会影响其他部分”的目标呢？ 首先，可以通过职责划分来分离关注点，面向对象的关键所在，就是职责的识别和分配。每个功能的完成，都是通过一系列职责组成的“协作链条”完成的；当不同职责被合理分离之后，为了实现新的功能只需构造新的“协作链条”，而需求变更也往往只会影响到少数职责的定义和实现...... 其次，可以利用软件系统各部分的通用性不同进行关注点分离。不同的通用程度意味着变化的可能性不同，将通用性不同的部分分离有利于通用部分的重用，也便于专用部分修改...... 另外，还可以先考虑大粒度的子系统，而暂时忽略子系统是如何通过更小粒度的模块和类组成的...... 总结了上述的架构设计关注点分离原理。可以说，根据职责分离关注点，根据通用性分离关注点，根据不同粒度级别分离关注点是三种位于不同“维度“的思维方式，所以在实际工作中必须综合运用这些手段。 于是，不难理解分层的细化、分区的引入、机制的提取这3种划分子系统手段之间的关系：它们处在思维的3个维度上。 首先，分层和机制位于不同的维度：职责维度和通用维度。 另外，是否引入分区，设计所“覆盖”的Scope是完全相同的。原因是层的粒度较大，而是层内部引入的分区的粒度更小，便于组合出一个个功能（支持迭代开发）。这是第三维：粒度。 看来，分层的细化、分区的引入、机制的提取这3个手段不是相互替代的关系，而是相辅相成的关系。 13.1.5. 探究：划分子系统的4个重要原则 重要的内容就值得多讲几遍。 下面的分层的细化、分区的引入、机制的提取这3种策略背后的4个通用设计原则： 职责不同的单元规划不同子系统 通用性不同的单元划归不同子系统 需要不同开发技能的单元划归不同子系统 兼顾工作量的相对均衡，进一步切分到多个原则综合作用的结果 "},"ch13/13.2.html":{"url":"ch13/13.2.html","title":"13.2. 接口设计的事实与缪误","keywords":"","body":"13.2. 接口设计的事实与缪误 世界是复杂的，很多东西难以直接获取。 例如直接最强幸福，是永远追不到的（《乐在工作》一书中说幸福是副产品）。 殊不知，合理的接口设计也不是“直接”得到的。 由于面向对象非常强调“自治”，许多人不知不觉的形成了一种错误认知：面向对象推崇“我的接口我做主”。很遗憾，“自治”正确。但“我的接口我做主”这个推断是错误的。 软件世界中本无模块。1968年，Dijkstra发表了第1篇关于层次结构的论文《The Structure of THE-multiprogramming System》（原文PDF）。1972年，Parnas发表论文《On the Criteria To Be Used in Decomposing Systems into Modules》论及了模块化和信息隐藏的话题......这是架构学科开始萌芽的标志。 那么，为什么要对软件进行模块化设计呢？是为了解决复杂性更高的大问题。于是，我们突然领悟：对问题进行分解，分别解决小问题，其实这只是手段。每个架构师应该牢记： “分”是手段，“合”是目的。不能“合”在一起支持更高层次功能的模块，又有何用呢？ 因此，我们必须把模块放在协作的上下文之中进行考虑。架构师设计接口时，要考虑的重点是“为了实现软件系统的一系列功能，这个软件单元要和其他哪些单元如何协作”，总结成一句话就是： 协作决定接口 相反，直接设计接口，是很多“面向接口的”架构依然拙劣的原因之一。类似“我的接口我做主”的观点是错误的，每个模块或子系统（甚至类）无视协作需要而进行的接口定义很难顺畅的被其他模块或子系统使用。 "},"ch13/13.3.html":{"url":"ch13/13.3.html","title":"13.3. 逻辑架构设计的整体思维套路","keywords":"","body":"13.3. 逻辑架构设计的整体思维套路 13.3.1. 整体思路：质疑驱动的逻辑架构设计 要点如下： 质疑驱动 结构设计和行为设计相分离 模板不是一天建成的。需求对架构设计的“驱动”作用，是伴随着架构师“不断设计中间成果 -> 不断质疑中间成果 -> 不断调整完善细化中间成果”的过程渐进展开的。打个比方，需求就像“缓释胶囊”，功能、质量、约束这3类“药物成分”的药力并不是一股脑释放的，而是缓缓释放的--“缓释”的控制者必然是人，是架构师 “药力释放机理” -- 逻辑架构设计的整体思维套路 先考虑结构方面的切分。手段是上面所讲的分层的细分、分区的引入、机制的提取。 然后，让切分出的职责协作起来，验证能否完成功能。这个工作，可以借助时序图进行。 此时，结构和行为方面各进行了一定的设计，就应开始质疑自己的设计。架构师要从两个角度质疑： 功能方面，特殊的功能支持吗？ 质量方面，耦合性、重用性、性能等怎么样？ 如此循环思维，不断将设计推向深入......其间，会涉及接口的定义，建议用“包-接口图”作为从结构到行为过度的桥梁，从而识别接口。至于接口的明确定义（接口包含的方法为何），则要进一步考虑基于职责的具体交互过程。 13.3.2. 过程串联：给初学者 第1步，根据当前理解切分。质疑驱动的逻辑架构设计整体思路，是从运用分层的细化、分区的引入、机制的提取进行子系统划分开始。 第2步，找到某功能的参与单元。弱找不到明显缺单元，就可以直接返回到第1步，以补充遗漏的职责单元。 第3步，让它们协作完成功能。研究第2步找到的参与单元之间的协作关系，看看能否完成预期功能，完成的怎么样？ 第4步，质疑并推进设计的深入。通过质疑“对不对”和“好不好”，可以发现新职责，或者调整协作方式。这意味着，第1步的子系统切分方案被调整、被优化......如此循环。 13.3.3. 案例示范：自己设计MyZip MyZip的概念架构设计，它将和需求一起，影响MyZip的细化架构设计。 下面主要是演示如何以质疑驱动的思路，设计MyZip的逻辑架构视图。 首先，考虑结构方面的切分，3种划分子系统的手段都运用上。 分层的细分。压缩实现层从原来的压缩控制层中分离出来。回忆一下之前的“子系统划分策略背后的4大原则”。无论是从职责不同的角度，还是从所需技能的角度考虑，两者都应该分离成为单独的“子系统”。 分区的引入。界面交互层必须进一步分区，例如：支持右键菜单的“Windows外壳扩展”部分被独立。 机制的提取。例子是智能缓冲机制，它应该成为一个通用性的基础子系统。同时，为了使它可重用，缓冲区不负责“缓冲区已满”时的具体处理而是毁掉外部单元进行。再者，为了提高使用友好性，缓冲区具有一定“智能”，它会自动保存溢出的部分，从而简化使用缓冲区的接口。 然后，让切分出来的职责协作起来，验证能否完成功能。我们来回答“切分之后的结构能支持压缩的协作吗？”的问题。回忆一下之前提到的增量建模技巧--不要急于“一口吃个胖子”。 如此循环，早晚要定义子系统的接口。下面是包-接口图，帮助架构师明确需要哪些接口（还没有到接口内方法定义一级）。 再次从结构设计跳到行为设计。现在在该更明确考虑压缩了。接下来，我们要演示ZipOneFile的设计。同样，遵循“先大局，后局部”的设计原则。具体设计决策是，让“控制”担当ZipOneFile的职责，而不是让“压缩实现”来担负--原因是希望“压缩实现”不须感知File的概念而能够更大程度上的被重用(例如对数据包而非文件进行压缩)。 我们来进一步的明确接口的方法定义...... "},"ch13/13.4.html":{"url":"ch13/13.4.html","title":"13.4. 更多经验总结","keywords":"","body":"13.4. 更多经验总结 13.4.1. 逻辑架构设计的10条经验要点 我们归纳了逻辑架构设计的10条经验要点，其中，如何划分子系统，如何定义接口，如何运用质疑驱动的事物套路等已经介绍，其他几点再继续简单介绍。 划分子系统：分层的细化 划分子系统：分区的引入 划分子系统：机制的提取 接口的定义：协作决定接口 选用序列图：杜绝协作图 包-接口图：从结构到行为的桥 灰盒包图：描述关键子系统 循序渐进的螺旋思维 设计模型：包内结构 设计模式：包间协作 13.4.2. 简述：逻辑架构设计中设计模式应用 设计模式是Class Level的设计，它如何用于架构一级的设计呢？ 基本观点是：让Class和SubSystem搭上关系。不难理解，设计模式用于架构设计主要有两种方式： 明确子系统内的结构 明确包间的协作关系 如何做呢？答案是灰盒包图。下图中说明了灰盒包图的意义，它打破了“子系统黑盒”，关系子系统中的关键类，从而可以更到位的说明子系统之间的协作关系，并成为设计模式应用的基础。 例如，我们对比一下黑盒包图和灰盒包图（背景是项目关系系统甘特图展示的问题）。后者明确了子系统之间的交互机制，还显式的说明了Adpter设计模式的应用--这就是灰盒包图的价值。 13.4.3. 简述：逻辑架构设计的建模支持 工欲善其事，必先利其器。在实践中必须选择最适合的模型，甚至做一些改造工作让UML更适合特定的实践目的。例如：灰盒包图就是一种“专门说明重要子系统设计”的UML图的应用。 另外，包-接口图是类图的一种特定形式，它包含“包（package）”和“接口（interface）”两种主要元素。这种图的作用很专一：说明包之间的协作需要哪些接口。逻辑架构设计中，包-接口图是从结构设计到行为设计的思维桥梁。 最后，“逻辑架构设计的整体思维套路”时已亮明了观点：逻辑架构的设计，应该使结构设计和行为设计相分离。这样才利于更有效的思维。不信？请看下面所示的“设计图”（这是很多设计者习惯的思维方式）。思维清楚吗？思维混乱的原因：将结构和行为过多的混在了一起。 推荐用时序图（它较为专注于行为设计）辅助逻辑架构设计，尽量不要用协作图（虽然在UML 1.4中，它和时序图等价，但从形式上它的“结构气”太重）。 "},"ch13/13.5.html":{"url":"ch13/13.5.html","title":"13.5. 贯穿案例","keywords":"","body":"13.5. 贯穿案例 我们来继续贯穿案例：PASS系统的架构设计。首先应注意两点： 第一，细化架构的重要“输入”之一是概念架构设计，不应忽视，比较细化架构设计是整个架构设计过程中的一个阶段。例如，之前进行的“基于鲁棒图的初步设计”，以及“高层分割考虑”。 第二，5视图方法的运用，总体而言是5个视图的设计穿插进行的，对复杂系统而言，根本不可能将逻辑视图设计完全之后再考虑其他视图。而本案例的PASS系统具有很强的分布特点，所以必然较早的考虑到物理视图对逻辑设计的影响。例如，PASS服务器作为一个物理架构元素的“节点(Node)”，它之上“跑”的逻辑架构“逻辑层(Layer)”有哪些呢？ 进入细化架构阶段的逻辑架构设计，常以初步设计为基础，借助分层细化、分层引入、机制提取等手段。对PASS服务器软件进行逻辑架构的结构设计。 从结构设计跳到行为设计，常用手段是画时序图。它处于逻辑架构设计的“螺旋式”整体思维讨论的起始循环，是进一步深入设计的基础。 有了不同职责单元之间具体的协作关系，就可以展开细致的“质疑”了--别忘了，架构设计是质疑驱动的。 处方检查服务能被医生工作站访问到吗？毕竟前者位于PASS服务器上......于是，设计中要进一步明确“远程调用机制”。 这样一个分布式的系统，访问服务之前要经过什么样的验证呢......于是，进一步考虑安全性的支持。 不同的医生不停的开处方，处方检查功能会不会很慢？常用药的用药规则应该常驻内存，这样才能提升性能......于是，设计要进一步明确Cache等提升性能的机制。 ...... 于是，自然而然地，沿着逻辑架构设计的“螺旋式”整体思维套路思考，我们就能意识到“结构设计”要继续完善和细化。基于对远程调用、安全性、高性能的质疑，改进的“结构设计”后就得到下面的逻辑架构图。 "}}